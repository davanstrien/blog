{
  
    
        "post0": {
            "title": "Using 🤗 datasets for image search",
            "content": "tl;dr it&#39;s really easy to use the huggingface datasets library to create an image search application but it might not be suitable for sharing. update an updated version of this post is on the 🤗 blog! . 🤗 Datasets is a library for easily accessing and sharing datasets, and evaluation metrics for Natural Language Processing (NLP), computer vision, and audio tasks. source . When datasets was first launched it was more usually associated with text data and nlp. However, datasets has got support for images. In particular there is now a datasets feature type for images. In this blog post I try and play around with this new datatype, in combination with some other nice features of the library to make an image search app. . To start lets take a look at the image feature. We can use the wonderful rich libary to poke around python objects (functions, classes etc.) . from rich import inspect from datasets.features import features . inspect(features.Image, help=True) . ╭──────────────────── &lt;class &#39;datasets.features.image.Image&#39;&gt; ─────────────────────╮ │ def Image(id: Union[str, NoneType] = None) -&gt; None: │ │ │ │ Image feature to read image data from an image file. │ │ │ │ Input: The Image feature accepts as input: │ │ - A :obj:`str`: Absolute path to the image file (i.e. random access is allowed). │ │ - A :obj:`dict` with the keys: │ │ │ │ - path: String with relative path of the image file to the archive file. │ │ - bytes: Bytes of the image file. │ │ │ │ This is useful for archived files with sequential access. │ │ │ │ - An :obj:`np.ndarray`: NumPy array representing an image. │ │ - A :obj:`PIL.Image.Image`: PIL image object. │ │ │ │ dtype = &#39;dict&#39; │ │ id = None │ │ pa_type = None │ ╰──────────────────────────────────────────────────────────────────────────────────╯ . We can see there a few different ways in which we can pass in our images. We&#39;ll come back to this in a little while. . A really nice feature of the datasets library (beyond the functionality for processing data, memory mapping etc.) is that you get some nice things for free. One of these is the ability to add a faiss index. faiss is a &quot;library for efficient similarity search and clustering of dense vectors&quot;. . The datasets docs show and example of using faiss for text retrieval. What I&#39;m curious about doing is using the faiss index to search for images. This can be super useful for a number of reasons but also comes with some potential issues. . The dataset: &quot;Digitised Books - Images identified as Embellishments. c. 1510 - c. 1900. JPG&quot; . This is a dataset of images which have been pulled from a collection of digitised books from the British Library. These images come from books across a wide time period and from a broad range of domains. These images were extracted using information in the OCR output for each book. As a result it&#39;s known which book the images came from but not necessarily anything else about that image i.e. what it is of. . Some attempts to help overcome this have included uploading the images to flickr. This allows people to tag the images or put them into various different categories. . There have also been projects to tag the dataset using machine learning. This work already makes it possible to search by tags but we might want a &#39;richer&#39; ability to search. For this particular experiment I will work with a subset of the collections which contain &quot;embellishments&quot;. This dataset is a bit smaller so will be better for experimenting with. We can get the data from the BL repository: https://doi.org/10.21250/db17 . !aria2c -x8 -o dig19cbooks-embellishments.zip &quot;https://bl.iro.bl.uk/downloads/ba1d1d12-b1bd-4a43-9696-7b29b56cdd20?locale=en&quot; . !unzip -q dig19cbooks-embellishments.zip . Install required packages . There are a few packages we&#39;ll need for this work. To start with we&#39;ll need the datasets library. . import sys !{sys.executable} -m pip install datasets . Now we have the data downloaded we&#39;ll try and load it into datasets. There are various ways of doing this. To start with we can grab all of the files we need. . from pathlib import Path . files = list(Path(&#39;embellishments/&#39;).rglob(&quot;*.jpg&quot;)) . Since the file path encodes the year of publication for the book the image came from let&#39;s create a function to grab that. . def get_parts(f:Path): _,year,fname = f.parts return year, fname . &#128248; Loading the images . The images are fairly large, since this is an experiment we&#39;ll resize them a little using the thumbnail method (this makes sure we keep the same aspect ratio for our images) . from PIL import Image import io . def load_image(path): with open(path, &#39;rb&#39;) as f: im = Image.open(io.BytesIO(f.read())) im.thumbnail((224,224)) return im . im = load_image(files[0]) im . Where is the image &#129300; . You may have noticed that the load_image function doesn&#39;t load the filepath into pillow directly. Often we would do Image.open(filepath.jpg). This is done deliberately. If we load it this way when we inspect the resulting image you&#39;ll see that the filepath attribute is empty. . inspect(im) . ╭─────────────────────── &lt;class &#39;PIL.JpegImagePlugin.JpegImageFile&#39;&gt; ───────────────────────╮ │ ╭───────────────────────────────────────────────────────────────────────────────────────╮ │ │ │ &lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=200x224 at 0x7FBBB392D040&gt; │ │ │ ╰───────────────────────────────────────────────────────────────────────────────────────╯ │ │ │ │ app = {&#39;APP0&#39;: b&#39;JFIF x00 x01 x01 x00 x00 x01 x00 x01 x00 x00&#39;} │ │ applist = [(&#39;APP0&#39;, b&#39;JFIF x00 x01 x01 x00 x00 x01 x00 x01 x00 x00&#39;)] │ │ bits = 8 │ │ custom_mimetype = None │ │ decoderconfig = (2, 0) │ │ decodermaxblock = 65536 │ │ encoderconfig = (False, -1, -1, b&#39;&#39;) │ │ encoderinfo = {} │ │ filename = &#39;&#39; │ │ format = &#39;JPEG&#39; │ │ format_description = &#39;JPEG (ISO 10918)&#39; │ │ fp = None │ │ height = 224 │ │ huffman_ac = {} │ │ huffman_dc = {} │ │ icclist = [] │ │ im = &lt;ImagingCore object at 0x7fbba120dc10&gt; │ │ info = { │ │ &#39;jfif&#39;: 257, │ │ &#39;jfif_version&#39;: (1, 1), │ │ &#39;jfif_unit&#39;: 0, │ │ &#39;jfif_density&#39;: (1, 1) │ │ } │ │ layer = [(1, 2, 2, 0), (2, 1, 1, 1), (3, 1, 1, 1)] │ │ layers = 3 │ │ map = None │ │ mode = &#39;RGB&#39; │ │ palette = None │ │ pyaccess = None │ │ quantization = { │ │ 0: [ │ │ 2, │ │ 2, │ │ 1, │ │ 2, │ │ 3, │ │ 6, │ │ 7, │ │ 9, │ │ 2, │ │ 2, │ │ 2, │ │ 3, │ │ 4, │ │ 8, │ │ 8, │ │ 8, │ │ 2, │ │ 2, │ │ 2, │ │ 3, │ │ 6, │ │ 8, │ │ 10, │ │ 8, │ │ 2, │ │ 2, │ │ 3, │ │ 4, │ │ 7, │ │ 12, │ │ 11, │ │ 9, │ │ 3, │ │ 3, │ │ 5, │ │ 8, │ │ 10, │ │ 15, │ │ 14, │ │ 11, │ │ 3, │ │ 5, │ │ 8, │ │ 9, │ │ 11, │ │ 15, │ │ 16, │ │ 13, │ │ 7, │ │ 9, │ │ 11, │ │ 12, │ │ 14, │ │ 17, │ │ 17, │ │ 14, │ │ 10, │ │ 13, │ │ 13, │ │ 14, │ │ 16, │ │ 14, │ │ 14, │ │ 14 │ │ ], │ │ 1: [ │ │ 2, │ │ 3, │ │ 3, │ │ 7, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 3, │ │ 3, │ │ 4, │ │ 9, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 3, │ │ 4, │ │ 8, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 7, │ │ 9, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14, │ │ 14 │ │ ] │ │ } │ │ readonly = 0 │ │ size = (200, 224) │ │ tile = [] │ │ width = 200 │ ╰───────────────────────────────────────────────────────────────────────────────────────────╯ . . You can also directly see this . im.filename . &#39;&#39; . Pillow usually loads images in a lazy way i.e. it only opens them when they are needed. The filepath is used to access the image. We can see the filename attribute is present if we open it from the filepath . im_file = Image.open(files[0]) im_file.filename . &#39;/Users/dvanstrien/Documents/daniel/blog/_notebooks/embellishments/1855/000811462_05_000205_1_The Pictorial History of England being a history of the people as well as a hi_1855.jpg&#39; . The reason I don&#39;t want the filename attribute present here is because not only do I want to use datasets to process our images but also store the images. If we pass a Pillow object with the filename attribute datasets will also use this for loading the images. This is often what we&#39;d want but we don&#39;t want this here for reasons we&#39;ll see shortly. . Preparing images for datasets . We can now load our images. What we&#39;ll do is is loop through all our images and then load the information for each image into a dictionary. . from collections import defaultdict . data = defaultdict(list) . from tqdm import tqdm . for file in tqdm(files): try: #load_image(file) year, fname = get_parts(file) data[&#39;fname&#39;].append(fname) data[&#39;year&#39;].append(year) data[&#39;path&#39;].append(str(file)) except: Image.UnidentifiedImageError pass . 100%|████████████████████████████████████████████████████████████████████████████████████████████| 416944/416944 [00:05&lt;00:00, 77169.45it/s] . We can now load the from_dict method to create a new dataset. . from datasets import Dataset . dataset = Dataset.from_dict(data) . We can look at one example to see what this looks like. . dataset[0] . {&#39;fname&#39;: &#39;000811462_05_000205_1_The Pictorial History of England being a history of the people as well as a hi_1855.jpg&#39;, &#39;year&#39;: &#39;1855&#39;, &#39;path&#39;: &#39;embellishments/1855/000811462_05_000205_1_The Pictorial History of England being a history of the people as well as a hi_1855.jpg&#39;} . Loading our images . At the moment our dataset has the filename and full path for each image. However, we want to have an actual image loaded into our dataset. We already have a load_image function. This gets us most of the way there but we might also want to add some ability to deal with image errors. The datasets library has gained increased uspport for handling None types- this includes support for None types for images see pull request 3195. . We&#39;ll wrap our load_image function in a try block, catch a Image.UnidentifiedImageError error and return None if we can&#39;t load the image. . def try_load_image(filename): try: image = load_image(filename) if isinstance(image, Image.Image): return image except Image.UnidentifiedImageError: return None . %%time dataset = dataset.map(lambda example: {&quot;img&quot;: try_load_image(example[&#39;path&#39;])},writer_batch_size=50) . CPU times: user 51min 42s, sys: 4min 31s, total: 56min 13s Wall time: 1h 10min 31s . Let&#39;s see what this looks like . dataset . Dataset({ features: [&#39;fname&#39;, &#39;year&#39;, &#39;path&#39;, &#39;img&#39;], num_rows: 416944 }) . We have an image column, let&#39;s check the type of all our features . dataset.features . {&#39;fname&#39;: Value(dtype=&#39;string&#39;, id=None), &#39;year&#39;: Value(dtype=&#39;string&#39;, id=None), &#39;path&#39;: Value(dtype=&#39;string&#39;, id=None), &#39;img&#39;: Image(id=None)} . This is looking great already. Since we might have some None types for images let&#39;s get rid of these. . dataset = dataset.filter(lambda example: example[&#39;img&#39;] is not None) . dataset . Dataset({ features: [&#39;fname&#39;, &#39;year&#39;, &#39;path&#39;, &#39;img&#39;], num_rows: 416935 }) . You&#39;ll see we lost a few rows by doing this filtering. We should now just have images which are successfully loaded. . If we access an example and index into the img column we&#39;ll see our image 😃 . dataset[10][&#39;img&#39;] . Push all the things to the hub! . One of the super awesome things about the huggingface ecosystem is the huggingface hub. We can use the hub to access models and datasets. Often this is used for sharing work with others but it can also be a useful tool for work in progress. The datasets library recently added a push_to_hub method that allows you to push a dataset to the hub with minimal fuss. This can be really helpful by allowing you to pass around a dataset with all the transformers etc. already done. . When I started playing around with this feature I was also keen to see if it could be used as a way of &#39;bundling&#39; everything together. This is where I noticed that if you push a dataset containing images which have been loaded in from filepaths by pillow the version on the hub won&#39;t have the images attached. If you always have the image files in the same place when you work with the dataset then this doesn&#39;t matter. If you want to have the images stored in the parquet file(s) associated with the dataset we need to load it without the filename attribute present (there might be another way of ensuring that datasets doesn&#39;t rely on the image file being on the file system -- if you of this I&#39;d love to hear about it). . Since we loaded our images this way when we download the dataset from the hub onto a different machine we have the images already there 🤗 . For now we&#39;ll push the dataset to the hub and keep them private initially. . dataset.push_to_hub(&#39;davanstrien/embellishments&#39;, private=True) . The repository already exists: the `private` keyword argument will be ignored. . Switching machines . At this point I&#39;ve created a dataset and moved it to the huggingface hub. This means it is possible to pickup the work/dataset elsewhere. . In this particular example, having access to a GPU is important. So the next parts of this notebook are run on Colab instead of locally on my laptop. . We&#39;ll need to login since the dataset is currently private. . !huggingface-cli login . _| _| _| _| _|_|_| _|_|_| _|_|_| _| _| _|_|_| _|_|_|_| _|_| _|_|_| _|_|_|_| _| _| _| _| _| _| _| _|_| _| _| _| _| _| _| _| _|_|_|_| _| _| _| _|_| _| _|_| _| _| _| _| _| _|_| _|_|_| _|_|_|_| _| _|_|_| _| _| _| _| _| _| _| _| _| _| _|_| _| _| _| _| _| _| _| _| _| _|_| _|_|_| _|_|_| _|_|_| _| _| _|_|_| _| _| _| _|_|_| _|_|_|_| To login, `huggingface_hub` now requires a token generated from https://huggingface.co/settings/token. (Deprecated, will be removed in v0.3.0) To login with username and password instead, interrupt with Ctrl+C. Token: Login successful Your token has been saved to /root/.huggingface/token Authenticated through git-credential store but this isn&#39;t the helper defined on your machine. You might have to re-authenticate when pushing to the Hugging Face Hub. Run the following command in your terminal in case you want to set this credential helper as the default git config --global credential.helper store . Once we&#39;ve done this we can load our dataset . from datasets import load_dataset dataset = load_dataset(&quot;davanstrien/embellishments&quot;, use_auth_token=True) . Using custom data configuration davanstrien--embellishments-543da8e15e8f0242 . Downloading and preparing dataset None/None (download: 2.38 GiB, generated: 2.50 GiB, post-processed: Unknown size, total: 4.88 GiB) to /root/.cache/huggingface/datasets/parquet/davanstrien--embellishments-543da8e15e8f0242/0.0.0/1638526fd0e8d960534e2155dc54fdff8dce73851f21f031d2fb9c2cf757c121... Dataset parquet downloaded and prepared to /root/.cache/huggingface/datasets/parquet/davanstrien--embellishments-543da8e15e8f0242/0.0.0/1638526fd0e8d960534e2155dc54fdff8dce73851f21f031d2fb9c2cf757c121. Subsequent calls will reuse this data. . Creating embeddings &#128376; . We now have a dataset with a bunch of images in it. To begin creating our image search app we need to create some embeddings for these images. There are various ways in which we can try and do this but one possible way is to use the clip models via the sentence_transformers library. The clip model from OpenAI learns a joint representation for both images and text which is very useful for what we want to do since we want to be able to input text and get back an image. We can download the model using the SentenceTransformer class. . from sentence_transformers import SentenceTransformer, util model = SentenceTransformer(&#39;clip-ViT-B-32&#39;) . ftfy or spacy is not installed using BERT BasicTokenizer instead of ftfy. . This model will encode either an image or some text returning an embedding. We can use the map method to encode all our images. . ds_with_embeddings = dataset.map( lambda example: {&#39;embeddings&#39;:model.encode(example[&#39;img&#39;],device=&#39;cuda&#39;)}, batch_size=32) . We can &quot;save&quot; our work by pushing back to the hub . ds_with_embeddings.push_to_hub(&#39;davanstrien/embellishments&#39;, private=True) . Pushing split train to the Hub. The repository already exists: the `private` keyword argument will be ignored. . If we were to move to a different machine we could grab our work again by loading it from the hub 😃 . from datasets import load_dataset ds_with_embeddings = load_dataset(&quot;davanstrien/embellishments&quot;, use_auth_token=True) . Using custom data configuration davanstrien--embellishments-c2c1f142f272db02 . Downloading and preparing dataset None/None (download: 3.19 GiB, generated: 3.30 GiB, post-processed: Unknown size, total: 6.49 GiB) to /root/.cache/huggingface/datasets/parquet/davanstrien--embellishments-c2c1f142f272db02/0.0.0/1638526fd0e8d960534e2155dc54fdff8dce73851f21f031d2fb9c2cf757c121... Dataset parquet downloaded and prepared to /root/.cache/huggingface/datasets/parquet/davanstrien--embellishments-c2c1f142f272db02/0.0.0/1638526fd0e8d960534e2155dc54fdff8dce73851f21f031d2fb9c2cf757c121. Subsequent calls will reuse this data. . We now have a new column which contains the embeddings for our images. We could manually search through these and compare it to some input embedding but datasets has an add_faiss_index method. This uses the faiss library to create an efficient index for searching embeddings. For more background on this library you can watch this youtube video . ds_with_embeddings[&#39;train&#39;].add_faiss_index(column=&#39;embeddings&#39;) . Dataset({ features: [&#39;fname&#39;, &#39;year&#39;, &#39;path&#39;, &#39;img&#39;, &#39;embeddings&#39;], num_rows: 416935 }) . Image search . We now have everything we need to create a simple image search. We can use the same model we used to encode our images to encode some input text. This will act as the prompt we try and find close examples for. Let&#39;s start with &#39;a steam engine&#39;. . prompt = model.encode(&quot;A steam engine&quot;) . We can see what this looks like . prompt . array([-4.68399227e-02, -1.25237599e-01, 1.25164926e-01, 1.23583399e-01, 5.36684394e-02, -2.80560672e-01, 2.89631691e-02, -9.63450074e-01, -1.52872965e-01, -3.83016393e-02, 9.01967064e-02, -5.84575422e-02, 1.04646191e-01, 2.44443744e-01, 1.38233244e-01, -3.97525132e-02, 4.35137331e-01, -4.26820181e-02, -8.48560631e-02, -6.94137365e-02, 6.25562131e-01, 3.68572891e-01, 3.34365219e-01, -3.37864846e-01, -2.53632635e-01, -3.01467925e-01, -1.56484097e-01, 2.94869483e-01, -1.89204350e-01, -1.13111593e-01, -1.46938376e-02, 2.97405511e-01, -2.92487741e-01, 3.56931627e-01, 1.44009173e-01, 7.53008351e-02, -1.02462962e-01, 2.26309776e-01, -3.77506733e-01, 4.75439876e-02, -8.52131844e-03, 7.40285963e-03, -1.36876494e-01, 1.12041593e-01, 3.65501434e-01, -9.37360153e-02, 1.00782610e-01, -3.86462212e-01, -1.39045209e-01, -2.31989667e-01, -2.62126565e-01, 8.75059143e-02, -9.87479314e-02, 7.31039718e-02, -5.99793851e-01, -5.31058311e-01, 1.46116272e-01, 1.58094600e-01, -5.31955510e-02, 1.91384852e-01, 1.16943717e-01, -4.84316409e-01, -1.38332695e-01, 1.76510841e-01, -2.17938051e-01, -1.00890748e-01, -4.45051998e-01, 2.71521568e-01, -1.12926617e-01, -3.37198257e-01, -1.34169117e-01, -7.38745630e-02, -1.23398125e-01, 3.62316787e-01, 9.09636840e-02, -3.20305794e-01, 5.82561374e-01, -3.51719618e-01, -1.05368085e-02, -3.90766770e-01, -3.18382740e-01, 5.37567735e-02, -6.24650240e-01, 2.18755245e-01, 3.51645321e-01, -3.01214606e-02, -8.49011913e-02, -3.29971045e-01, 2.13861912e-01, -1.10820271e-02, -3.52595486e-02, -3.70746814e-02, -1.35805202e+00, 3.35692495e-01, -2.83742435e-02, -1.39813796e-01, 3.66676860e-02, 2.62957454e-01, 2.52151459e-01, -6.14355244e-02, 2.01516539e-01, -4.14117992e-01, -2.58466527e-02, 1.06067717e-01, 3.14981639e-02, -1.45749748e-02, -5.94865866e-02, 2.55122900e-01, -3.30369681e-01, 6.39781356e-04, 1.65513411e-01, 7.37893358e-02, -4.69729975e-02, 3.36943477e-01, 4.38236594e-02, -4.21047479e-01, -1.14590853e-01, 1.49240956e-01, 1.34405270e-01, 3.97198983e-02, -1.20852023e-01, -7.22009778e-01, 1.17442548e-01, -7.35135227e-02, 5.45979321e-01, 1.76602621e-02, 6.59747049e-02, 8.00846070e-02, 3.87920737e-01, -3.57501693e-02, 1.19425125e-01, -2.89906412e-01, -2.84183323e-02, 5.73142338e+00, 1.24172762e-01, -1.59575850e-01, -5.33452034e-02, -1.77120879e-01, 2.14188576e-01, -3.49292234e-02, -4.76958305e-02, -1.05941862e-01, -1.58911452e-01, 1.87136307e-02, -2.16531213e-02, 1.37230158e-01, 4.62583750e-02, 2.19857365e-01, 3.41235586e-02, -3.29913348e-02, 9.88523886e-02, -1.30611554e-01, -1.53349772e-01, 2.20886514e-01, 1.53534949e-01, -4.27889526e-01, -4.12531018e-01, 2.70397663e-01, 1.88448757e-01, 4.66853082e-02, 2.63707846e-01, -9.56512764e-02, -3.26435685e-01, -1.24463499e-01, 4.49354291e-01, -4.17843968e-01, -5.27932420e-02, -1.28314078e-01, -1.19249836e-01, -1.19294032e-01, 3.73742878e-01, 2.07954675e-01, -1.41953439e-01, 3.89361024e-01, -1.99988037e-01, 3.62350583e-01, -8.77851099e-02, -1.08132876e-01, -9.82177258e-03, 1.80039972e-01, 1.35815665e-02, 3.20201695e-01, -1.74580999e-02, -1.08204901e-01, -2.29793668e-01, -2.09628209e-01, 4.13929313e-01, -1.73814282e-01, -4.10574347e-01, -1.59104809e-01, -6.01581074e-02, 6.22577034e-02, -3.67693931e-01, 1.85215116e-01, -2.03229636e-01, -8.92911255e-02, -4.25831258e-01, -1.45366028e-01, 2.45514482e-01, -1.65927559e-01, -2.54413635e-02, -2.91361034e-01, -8.33243579e-02, -4.79405448e-02, 6.35769814e-02, 8.04642588e-02, 5.31384498e-02, 2.50850171e-02, -8.98692310e-02, 4.97757077e-01, 6.37893498e-01, -2.58815974e-01, 4.14507166e-02, 9.45882648e-02, -9.01474580e-02, -9.18833911e-02, -2.48883665e-01, 9.16991904e-02, -2.93194801e-01, -1.49350330e-01, 7.20755905e-02, -9.76985693e-03, -4.70465049e-02, -2.78597653e-01, -7.63949528e-02, -3.14843357e-01, 3.18657011e-01, -3.06758255e-01, -2.06573829e-01, -2.20574200e-01, 1.81351285e-02, 2.57636189e-01, 2.39799708e-01, -2.31798366e-01, -8.34087562e-03, 6.13241374e-01, -2.10393399e-01, 2.52263397e-01, 1.66839644e-01, -2.71174073e-01, 2.31348664e-01, 1.15150154e-01, 2.23357946e-01, 1.37287825e-01, -8.56669843e-02, 3.43877286e-01, -1.09687179e-01, 3.24211985e-01, -4.53893900e-01, -2.30711773e-01, -2.48840563e-02, 1.80964172e-01, 4.73472506e-01, 5.22104502e-01, 9.96741354e-02, 1.87694326e-01, 2.41730541e-01, -2.78556377e-01, 7.48419687e-02, 2.80560136e-01, -1.25464931e-01, 1.51028201e-01, 1.39490321e-01, 5.16689643e-02, 5.30310348e-02, 1.61938250e-01, 3.72225225e-01, -4.49403644e-01, 1.19608052e-01, 2.43661910e-01, 9.89501849e-02, 2.74168640e-01, 4.84039634e-02, -1.19901955e-01, -1.57916725e-01, -2.20868304e-01, 1.03498720e-01, 3.99750322e-01, 1.03758566e-01, 8.08660090e-02, 1.68566346e-01, -3.42532575e-01, 2.51480471e-02, 1.23976640e-01, -2.10433707e-01, 2.81242996e-01, 2.39082754e-01, 2.01786831e-02, 4.61297363e-01, 5.62884361e-02, 2.15039015e-01, -1.65275872e-01, 1.01690084e-01, -4.50959802e-03, -4.46137577e-01, 4.31368239e-02, -4.51804757e-01, -2.26415813e-01, 1.31732523e-01, -2.00945437e-02, 1.77461311e-01, -1.64631978e-02, 4.40553159e-01, 1.41214132e-01, 3.42677176e-01, -2.23303795e-01, -2.10693538e-01, 1.94943929e-03, -2.33348235e-01, 4.64889407e-03, 5.71020804e-02, 1.99669391e-01, 5.72273111e+00, -2.95036316e-01, -5.13455391e-01, 1.87334672e-01, 4.09545094e-01, -7.09135592e-01, 1.89325869e-01, -6.14660345e-02, 3.29098284e-01, 2.82059342e-01, 3.48631829e-01, -9.74263549e-02, -4.83064592e-01, -1.35906041e-04, 3.44773471e-01, -3.56532484e-01, 5.36619090e-02, -1.85481656e+00, 3.87955368e-01, -1.83132842e-01, -1.34021699e-01, -1.84214741e-01, 6.85371086e-02, 1.10808179e-01, -6.64586425e-02, 6.85550272e-02, 1.81145087e-01, -2.15605676e-01, -1.09192222e-01, -7.09795505e-02, 1.77813157e-01, -2.76037157e-01, 2.19184965e-01, -3.35977226e-01, 1.01434961e-01, 4.24576849e-02, 6.37579709e-04, -1.23296835e-01, -6.84914351e-01, 5.02923191e-01, 2.19384342e-01, 4.92008686e-01, -1.94621727e-01, -2.48740703e-01, -1.32586688e-01, -1.77171156e-02, -4.71081585e-03, 1.58246011e-01, -3.27363521e-01, -3.30681592e-01, -2.68038437e-02, -1.85811728e-01, -1.84623767e-02, -3.22798610e-01, 3.07092518e-01, 1.06014945e-01, 3.20541680e-01, -2.55453944e-01, -2.30755419e-01, -1.19963072e-01, -2.04865620e-01, 4.02828932e-01, -3.01321566e-01, 4.01021272e-01, -3.02002877e-01, 1.42853945e-01, 2.94484437e-01, -2.06042349e-01, -3.03069353e-01, -2.83185482e-01, -1.03388466e-02, -1.03018671e-01, 4.25990820e-02, -2.94244856e-01, 3.19168091e-01, 3.89839858e-02, -1.95185751e-01, -9.88216847e-02, -4.01682496e-01, 4.60841119e-01, 1.40236557e-01, 1.49914265e-01, -4.25037295e-01, 2.63067722e-01, 1.31706342e-01, 3.21884871e-01, -2.39963964e-01, 4.01636630e-01, -2.55293436e-02, -7.36447945e-02, -8.34826380e-03, 1.11923724e-01, -2.71807779e-02, -3.35412771e-02, 2.33933121e-01, 3.33954431e-02, 3.56481314e-01, -8.09433609e-02, -1.82573602e-01, 1.75429478e-01, -3.23554099e-01, 9.15928558e-03, 1.54344559e-01, 2.50909716e-01, 1.45193070e-01, 2.48686507e-01, -9.65276286e-02, -2.73654372e-01, 5.46456315e-02, 1.83476061e-02, -1.61773548e-01, -2.97708124e-01, -1.74462572e-01, -1.14246726e-01, 2.32043359e-02, 1.98346555e-01, 2.31929243e-01, -9.74937603e-02, -2.26448864e-01, -6.31427839e-02, 2.23113708e-02, -3.72859359e-01, 2.47197479e-01, -3.65516663e-01, -3.24409932e-01, 1.83964625e-01, -3.17104161e-03, -2.66632497e-01, -1.86478943e-01, 1.11006252e-01, -3.93829793e-02, -3.11926544e-01, 2.88751245e-01, 2.66543150e-01, -1.74334750e-01, -4.89967108e-01, 3.38638097e-01, 2.47487854e-02, -3.66539627e-01, 5.78703731e-03, 1.11349493e-01, -2.60909855e-01, -4.34429348e-02, -4.47440267e-01, 2.80311018e-01, -6.46181554e-02, -2.93976814e-02, -3.02857161e-01, 2.10391358e-03, -3.70345414e-02, 7.15476647e-02, 4.39802915e-01, 2.11817563e-01, 6.87709302e-02, 5.68117499e-01, -2.40518659e-01, 2.59056687e-01, -1.32284269e-01, 1.28509507e-01, -1.94875181e-01, -2.68568173e-02, -7.85035193e-02, -2.49556839e-01, 1.44016743e-01, -2.98127495e-02, -1.41643599e-01, 1.77106410e-02, 1.83453292e-01, -1.39113069e-02, -1.97993904e-01, 3.07995021e-01, 3.31339300e-01, 2.07652867e-01, 1.27762616e-01, 2.26422980e-01, 1.94940835e-01, -4.90801185e-02, -5.35061479e-01, -2.99495637e-01, 3.68627608e-02, -4.15636569e-01, 6.44698918e-01, -4.50457260e-02, 7.05935210e-02, -1.11036956e-01, -1.42384216e-01, -7.05560222e-02, 2.86495592e-03, 3.45641613e-01, -5.66974521e-01, -1.34682715e-01, -2.59017110e-01, 3.27597320e-01, 1.04890786e-01, -3.11988890e-01, -2.32627541e-01, 3.14653963e-02, 2.76591361e-01, 1.66302443e-01, -2.39517853e-01], dtype=float32) . . We can use another method from the datasets library get_nearest_examples to get images which have an embedding close to our input prompt embedding. We can pass in a number of results we want to get back. . scores, retrieved_examples = ds_with_embeddings[&#39;train&#39;].get_nearest_examples(&#39;embeddings&#39;, prompt,k=9) . We can index into the first example this retrieves: . retrieved_examples[&#39;img&#39;][0] . This isn&#39;t quite a steam engine but it&#39;s also not a completely weird result. We can plot the other results to see what was returned. . import matplotlib.pyplot as plt . plt.figure(figsize=(20, 20)) columns = 3 for i in range(9): image = retrieved_examples[&#39;img&#39;][i] plt.subplot(9 / columns + 1, columns, i + 1) plt.imshow(image) . Some of these results look fairly close to our input prompt. We can wrap this in a function so can more easily play around with different prompts . def get_image_from_text(text_prompt, number_to_retrieve=9): prompt = model.encode(text_prompt) scores, retrieved_examples = ds_with_embeddings[&#39;train&#39;].get_nearest_examples(&#39;embeddings&#39;, prompt,k=number_to_retrieve) plt.figure(figsize=(20, 20)) columns = 3 for i in range(9): image = retrieved_examples[&#39;img&#39;][i] plt.title(text_prompt) plt.subplot(9 / columns + 1, columns, i + 1) plt.imshow(image) . get_image_from_text(&quot;An illustration of the sun behind a mountain&quot;) . Trying a bunch of prompts &#10024; . Now we have a function for getting a few results we can try a bunch of different prompts: . For some of these I&#39;ll choose prompts which are a broad &#39;category&#39; i.e. &#39;a musical instrument&#39; or &#39;an animal&#39;, others are specific i.e. &#39;a guitar&#39;. . | Out of interest I also tried a boolean operator: &quot;An illustration of a cat or a dog&quot;. . | Finally I tried something a little more abstract: &quot;an empty abyss&quot; . | . prompts = [&quot;A musical instrument&quot;, &quot;A guitar&quot;, &quot;An animal&quot;, &quot;An illustration of a cat or a dog&quot;, &quot;an empty abyss&quot;] . for prompt in prompts: get_image_from_text(prompt) . We can see these results aren&#39;t always right but they are usually some reasonable results in there. It already seems like this could be useful for searching for a the semantic content of an image in this dataset. However we might hold off on sharing this as is... . Creating a huggingface space? &#129335;&#127996; . One obvious next step for this kind of project is to create a hugginface spaces demo. This is what I&#39;ve done for other models . It was a fairly simple process to get a Gradio app setup from the point we got to here. Here is a screenshot of this app. . . However, I&#39;m a little bit vary about making this public straightaway. Looking at the model card for the CLIP model we can look at the primary intended uses: . Primary intended uses . We primarily imagine the model will be used by researchers to better understand robustness, generalization, and other capabilities, biases, and constraints of computer vision models. source This is fairly close to what we are interested in here. Particularly we might be interested in how well the model deals with the kinds of images in our dataset (illustrations from mostly 19th century books). The images in our dataset are (probably) fairly different from the training data. The fact that some of the images also contain text might help CLIP since it displays some OCR ability. . However, looking at the out-of-scope use cases in the model card: . Out-of-Scope Use Cases . Any deployed use case of the model - whether commercial or not - is currently out of scope. Non-deployed use cases such as image search in a constrained environment, are also not recommended unless there is thorough in-domain testing of the model with a specific, fixed class taxonomy. This is because our safety assessment demonstrated a high need for task specific testing especially given the variability of CLIP’s performance with different class taxonomies. This makes untested and unconstrained deployment of the model in any use case currently potentially harmful. source suggests that &#39;deployment&#39; is not a good idea. Whilst the results I got are interesting I haven&#39;t played around with the model enough yet (and haven&#39;t done anything more systematic to evaluate its performance and biases). Another additional consideration is the target dataset itself. The images are drawn from books covering a variety of subjects and time periods. There are plenty of books which represent colonial attitudes and as a result some of the images included may represent certain groups of people in a negative way. This could potentially be a bad combo with a tool which allows any arbitrary text input to be encoded as a prompt. . There may be ways around this issue but this will require a bit more thought. . Conclusion . Although I don&#39;t have a nice demo to show for it I did get to work out a few more details of how datasets handles images. I&#39;ve already used it to train some classification models and everything seems to be working smoothly. The ability to push images around on the hub will be super useful for many use cases too. . I plan to spend a bit more time thinking about whether there is a better way of sharing a clip powered image search for the BL book images or not... . 1. If you aren&#39;t familiar with datasets. A feature represents the datatype for different data you can have inside a dataset. For example you my have int32, timestamps and strings. You can read more about how features work in the docs↩ .",
            "url": "https://danielvanstrien.xyz/metadata/deployment/huggingface/ethics/huggingface-datasets/faiss/2022/01/13/image_search.html",
            "relUrl": "/metadata/deployment/huggingface/ethics/huggingface-datasets/faiss/2022/01/13/image_search.html",
            "date": " • Jan 13, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Using the 🤗 Hub for model storage",
            "content": "Intro . Part of what the flyswot should take care of is handle machine learning models. The flyswot tool is essentially just a command-line wrapper for the machine learning model. However, these two things the command-line tool, and the model, are kept separate for a number of reasons: . the flyswot tool might have changes separate from the model changing i.e. some new functionality is added or some bug fixed | we might want to update the model based on new training data or a change in the labels used | . We want to be able to release a new model without having to create a new release of the flyswot tool and vice-versa. As a result of this, both of these things are versioned separately. . We might want to keep our model separate because flyswot is made available as a Python Package. Since a computer vision model can be pretty large, we probably don&#39;t want this to be included as a part of the Python package. . How is this currently being done . Currently models are stored in a separate GitHub repository separate from the repository used to store the flyswot code. flyswot has some functionality for checking against this GitHub repository to see if a more recent remote model has superseded a local model. If there is a more recent model available (and a CLI flag indicates that the latest model should be used), then flyswot downloads the new model and stores it in a new directory. . What is wrong with this . Whilst this approach does work okay there is quite a surprising amount of code that is needed to take care of some of this. Currently the option to pass a specific snapshot of a model doesn&#39;t exist. . On the storage side although GitHub is great for storing code there are some limitations to it for storing large files. I&#39;ve created a GitHub action to create a release when new pull requests to update the model are made. This then creates a new release with date information in the filename. Again, this works okay, but there might be a better way... . &#129303; hub to the rescue? . I have already been using the huggingface hub when using other peoples models and uploading fine-tuned transformer models. However, digging around the docs, it seemed like there are a few things in this ecosystem that could be useful for flyswot. . What is the &#129303; hub? . If you haven&#39;t come across the 🤗 hub before, it is essentially a place where models can be uploaded and explored by others. So, for example, if I want a language model trained on Arabic text, I might find it in the hub. The goal is to help avoid duplication of effort and allow other people to use or adapt existing work. . This video gives a helpful overview of navigating the hub and finding models you might be interested in using. . Part of the aim of sharing the flyswot models on GitHub (or the 🤗 hub) is to make them available to other people to use. The 🤗 hub well supports this use case. We can easily share models (including large ones) because of the underpinning use of git-lfs. However, our interest is not only in sharing a model for others to use but also in grabbing the correct model for the flyswot CLI tool easier. Some other components might help here. . The hub vs huggingface_hub library . The 🤗 hub already provides a place to store the model. You can interact with this model using the web interface only but what we want is also to download models using our CLI from the hub. We already have a way to do this with GitHub, so ideally, we want something that works better than our current approach. . This is where the huggingface_hub Python Library might come in. This Python library provides us with various ways of interacting with the hub. This could give us enough ways of interacting with the hub that we can delete some of the code that currently does this with GitHub (and there is nothing nicer than deleting code 😃) . I&#39;ll use the remainder of this blog to see if we can use the 🤗 hub and the [huggingface_hub](https://pypi.org/project/huggingface-hub/) library for this purpose as a replacement for the current approach. . We&#39;ll start by installing the huggingface_hub library . !pip install huggingface_hub . Getting information about a model . One of the things we need to be able to do is get the latest version of the model. One way we could try and do this is by grabbing metadata about the model. This is the current approach taken by flyswot. We can import model_info to do this: . from huggingface_hub import model_info . info = model_info(&quot;distilbert-base-cased&quot;) info . ModelInfo: { modelId: distilbert-base-cased sha: 935ac13b473164bb9d578640e33d9f21144c365e lastModified: 2020-12-11T21:23:53.000Z tags: [&#39;pytorch&#39;, &#39;tf&#39;, &#39;distilbert&#39;, &#39;en&#39;, &#39;dataset:bookcorpus&#39;, &#39;dataset:wikipedia&#39;, &#39;arxiv:1910.01108&#39;, &#39;transformers&#39;, &#39;license:apache-2.0&#39;, &#39;infinity_compatible&#39;] pipeline_tag: None siblings: [ModelFile(rfilename=&#39;.gitattributes&#39;), ModelFile(rfilename=&#39;README.md&#39;), ModelFile(rfilename=&#39;config.json&#39;), ModelFile(rfilename=&#39;pytorch_model.bin&#39;), ModelFile(rfilename=&#39;tf_model.h5&#39;), ModelFile(rfilename=&#39;tokenizer.json&#39;), ModelFile(rfilename=&#39;tokenizer_config.json&#39;), ModelFile(rfilename=&#39;vocab.txt&#39;)] config: {&#39;model_type&#39;: &#39;distilbert&#39;} id: distilbert-base-cased private: False downloads: 3556770 library_name: transformers mask_token: [MASK] likes: 4 model-index: None cardData: {&#39;language&#39;: &#39;en&#39;, &#39;license&#39;: &#39;apache-2.0&#39;, &#39;datasets&#39;: [&#39;bookcorpus&#39;, &#39;wikipedia&#39;]} } . type(info) . huggingface_hub.hf_api.ModelInfo . You can see this gives us back a bunch of information about the model. We could for example grab the date the model was changed: . info.lastModified . &#39;2020-12-11T21:23:53.000Z&#39; . This already gives us what we need for checking if a model is updated in comparison to a local model already downloaded by the flyswot CLI. However we might be able to cut out some of this checking work. . Lets see if there are other ways we can do this in the library. Since huggingface_hub requires git-lfs lets start by installing this. . !apt install git-lfs . Reading package lists... Done Building dependency tree Reading state information... Done git-lfs is already the newest version (2.3.4-1). 0 upgraded, 0 newly installed, 0 to remove and 37 not upgraded. . We also need to make sure we have git-lfs setup . !git init &amp;&amp; git lfs install . hint: Using &#39;master&#39; as the name for the initial branch. This default branch name hint: is subject to change. To configure the initial branch name to use in all hint: of your new repositories, which will suppress this warning, call: hint: hint: git config --global init.defaultBranch &lt;name&gt; hint: hint: Names commonly chosen instead of &#39;master&#39; are &#39;main&#39;, &#39;trunk&#39; and hint: &#39;development&#39;. The just-created branch can be renamed via this command: hint: hint: git branch -m &lt;name&gt; Initialized empty Git repository in /Users/dvanstrien/Documents/daniel/blog/_notebooks/.git/ Updated git hooks. Git LFS initialized. . Downloading files from the hub . We can use hf_hub_url to get the url for a specific file from a repository . from huggingface_hub import hf_hub_url . onnx_model_url = hf_hub_url(&quot;davanstrien/flyswot-test&quot;, &quot;2021-09-22.onnx&quot;) onnx_model_url . &#39;https://huggingface.co/davanstrien/flyswot-test/resolve/main/2021-09-22.onnx&#39; . We can pass this url to cached_download, this will download the file for us if we don&#39;t have the latest version, we can also specify a place to download the file. This is important so we can make sure we put the file somewhere flyswot can find. . from huggingface_hub import cached_download . cached_download(onnx_model_url, cache_dir=&quot;.&quot;) . &#39;./de9d2ce054e3e410e3fc61b5c2ad55da7861d30e3b90aa018615b7d902e6e51e.1300a5792e44de2c59f4d25c4f7efd447ef91d69971a121e6b4df8b95047ad7c&#39; . If we try and download this again it won&#39;t download, and will instead return the path to the model . path = cached_download(onnx_model_url, cache_dir=&quot;.&quot;) path . &#39;./de9d2ce054e3e410e3fc61b5c2ad55da7861d30e3b90aa018615b7d902e6e51e.1300a5792e44de2c59f4d25c4f7efd447ef91d69971a121e6b4df8b95047ad7c&#39; . Downloading all files from the hub . This is quite close to what we want our current approach requires us to get a bunch of different files in a folder. To replicate this we can instead use snapshot_download . from huggingface_hub import snapshot_download . Let&#39;s see what this does . ?snapshot_download . Signature: snapshot_download( repo_id: str, revision: Union[str, NoneType] = None, cache_dir: Union[str, pathlib.Path, NoneType] = None, library_name: Union[str, NoneType] = None, library_version: Union[str, NoneType] = None, user_agent: Union[Dict, str, NoneType] = None, proxies=None, etag_timeout=10, resume_download=False, use_auth_token: Union[bool, str, NoneType] = None, local_files_only=False, ) -&gt; str Docstring: Downloads a whole snapshot of a repo&#39;s files at the specified revision. This is useful when you want all files from a repo, because you don&#39;t know which ones you will need a priori. All files are nested inside a folder in order to keep their actual filename relative to that folder. An alternative would be to just clone a repo but this would require that the user always has git and git-lfs installed, and properly configured. Note: at some point maybe this format of storage should actually replace the flat storage structure we&#39;ve used so far (initially from allennlp if I remember correctly). Return: Local folder path (string) of repo snapshot File: ~/miniconda3/envs/blog/lib/python3.8/site-packages/huggingface_hub/snapshot_download.py Type: function . This will do something similar to cached_download but will instead do it for a whole model repository. If we pass our repository it will download the directory if we don&#39;t have the latest version of the files, if for example, the model has been updated. . model = snapshot_download(&quot;davanstrien/flyswot-test&quot;, cache_dir=&quot;.&quot;) . model . &#39;./davanstrien__flyswot-test.main.e54a7421f5e5eb240783452ab734288f252bb402&#39; . If we look inside this directory we can see we have the files from the repository. . !ls {model} . 2021-09-22.onnx README.md modelcard.md vocab.txt . If we try and download it again we just get back the directory path without having to download the files again. . model = snapshot_download(&quot;davanstrien/flyswot-test&quot;, cache_dir=&quot;.&quot;) model . &#39;./davanstrien__flyswot-test.main.e54a7421f5e5eb240783452ab734288f252bb402&#39; . This gives a replication of what we currently have setup for flyswot in terms of downloading models. There are a few extra things we might want though to be able to make flyswot more flexible. First though let&#39;s look at how we can upload to the model hub. . Uploading to the hub . At the moment flyswot models are uploaded to a GitHub repository which then creates a release. It would be nice to simplify this and upload directly at the end of model training. For this we can use the Repository class. . from huggingface_hub import Repository . ?Repository . Init signature: Repository( local_dir: str, clone_from: Union[str, NoneType] = None, repo_type: Union[str, NoneType] = None, use_auth_token: Union[bool, str] = True, git_user: Union[str, NoneType] = None, git_email: Union[str, NoneType] = None, revision: Union[str, NoneType] = None, private: bool = False, skip_lfs_files: bool = False, ) Docstring: Helper class to wrap the git and git-lfs commands. The aim is to facilitate interacting with huggingface.co hosted model or dataset repos, though not a lot here (if any) is actually specific to huggingface.co. Init docstring: Instantiate a local clone of a git repo. If specifying a `clone_from`: will clone an existing remote repository, for instance one that was previously created using ``HfApi().create_repo(name=repo_name)``. ``Repository`` uses the local git credentials by default, but if required, the ``huggingface_token`` as well as the git ``user`` and the ``email`` can be explicitly specified. If `clone_from` is used, and the repository is being instantiated into a non-empty directory, e.g. a directory with your trained model files, it will automatically merge them. Args: local_dir (``str``): path (e.g. ``&#39;my_trained_model/&#39;``) to the local directory, where the ``Repository`` will be initalized. clone_from (``str``, `optional`): repository url (e.g. ``&#39;https://huggingface.co/philschmid/playground-tests&#39;``). repo_type (``str``, `optional`): To set when creating a repo: et to &#34;dataset&#34; or &#34;space&#34; if creating a dataset or space, default is model. use_auth_token (``str`` or ``bool``, `optional`, defaults to ``True``): huggingface_token can be extract from ``HfApi().login(username, password)`` and is used to authenticate against the hub (useful from Google Colab for instance). git_user (``str``, `optional`): will override the ``git config user.name`` for committing and pushing files to the hub. git_email (``str``, `optional`): will override the ``git config user.email`` for committing and pushing files to the hub. revision (``str``, `optional`): Revision to checkout after initializing the repository. If the revision doesn&#39;t exist, a branch will be created with that revision name from the default branch&#39;s current HEAD. private (``bool``, `optional`, defaults to ``False``): whether the repository is private or not. skip_lfs_files (``bool``, `optional`, defaults to ``False``): whether to skip git-LFS files or not. File: ~/miniconda3/envs/blog/lib/python3.8/site-packages/huggingface_hub/repository.py Type: type Subclasses: . I&#39;ll use flyswot-test as a way of playing around with this. To start with we can use Repository to clone the current version of the model. . repo = Repository(local_dir=&quot;flyswot-models&quot;, clone_from=&quot;davanstrien/flyswot-test&quot;) . Cloning https://huggingface.co/davanstrien/flyswot-test into local empty directory. . repo . &lt;huggingface_hub.repository.Repository at 0x7fb10cccbc10&gt; . We&#39;ll need to be logged in to push changes . from huggingface_hub import notebook_login notebook_login() . To start with let&#39;s mock making a change to some of the repo files and seeing how we can upload these changes. We can use the Repository class as a context manager to make changes and have them committed to our model repository. Here we update the vocab file to add a new label. . with Repository( local_dir=&quot;flyswot-models&quot;, clone_from=&quot;davanstrien/flyswot-test&quot;, git_user=&quot;Daniel van Strien&quot;, ).commit(&quot;update model&quot;): with open(&quot;vocab.txt&quot;, &quot;a&quot;) as f: f.write(&quot;new label&quot;) . /Users/dvanstrien/Documents/daniel/blog/_notebooks/flyswot-models is already a clone of https://huggingface.co/davanstrien/flyswot-test. Make sure you pull the latest changes with `repo.git_pull()`. Pulling changes ... To https://huggingface.co/davanstrien/flyswot-test e54a742..18d149e main -&gt; main . This could already be used at the end of our training script. Currently I have some util files that package up the model vocab, convert Pytorch to ONNX etc. This could easily be adapted to also push the updated model to the hub. There is only one thing we might still want to add. . Adding more metadata: creating revision branches . Currently flyswot uses filenames to capture metadata about the model version. The models are versioned using calendar versioning. This works okay but we might be able to manage this in a slightly better way. One of the nice features that hf_hub (the Python library) offers that flyswot currently doesn&#39;t support well is being able to pass in a specific revision when using snapshot_download. This would then allow someone to run a specific older version of the model. This might be useful for various different scenarios. To do this we&#39;ll create a revision branch for the date the model was created. All that we&#39;ll do now is pass in a formatted date as the revision. . from datetime import datetime . date_now = datetime.now() now = date_now.strftime(&quot;%Y-%m-%d&quot;) now . &#39;2021-12-30&#39; . with Repository( local_dir=&quot;flyswot-models&quot;, clone_from=&quot;davanstrien/flyswot-test&quot;, git_user=&quot;Daniel van Strien&quot;, revision=now, ).commit(f&quot;update model {now}&quot;): for model in Path(&quot;.&quot;).glob(&quot;.onnx&quot;): model.rename(f&quot;{now}-model.onnx&quot;) . /Users/dvanstrien/Documents/daniel/blog/_notebooks/flyswot-models is already a clone of https://huggingface.co/davanstrien/flyswot-test. Make sure you pull the latest changes with `repo.git_pull()`. Checked out 2021-12-30 from 2021-12-30. Your branch is up to date with &#39;origin/2021-12-30&#39;. Pulling changes ... Several commits (2) will be pushed upstream. The progress bars may be unreliable. Everything up-to-date . This creates a new revision branch for the current date. Since I also want to have the default branch be the current model we would also push the same model to the default branch. This would then mean that we end up with a bunch of different branches with model snapshots that could be passed in but for the default behavior we can easily grab the latest model by not specifying a revision. .",
            "url": "https://danielvanstrien.xyz/metadata/deployment/huggingface/flyswot/2021/12/30/hf-hub-model-storage.html",
            "relUrl": "/metadata/deployment/huggingface/flyswot/2021/12/30/hf-hub-model-storage.html",
            "date": " • Dec 30, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "flyswot",
            "content": "My previous series of posts/notes following the full stack course ended slightly abruptly. However, I didn’t give up on the dream of trying to get more experience of ‘deploying’ machine learning in a GLAM setting! One of the things I have been focusing on recently is a project which gave me the chance to use machine learning in somewhat of a production context. . This blog post will be a very short tl;dr on this project. . Detecting fake flysheets using computer vision . The Library has ‘legacy’ digitised content of manuscripts. Due to some limitations of the legacy system on which these manuscripts were shared many of the images have incorrect metadata. The metadata for these images is partially stored in the filename for the image. In particular many images which didn’t fit into an available category were given ‘end flysheet’ labels (this basically means part of the filename contains the string fse). These images may actually be other things like a frontcover, a scroll image, a box etc. . . The library is moving to a new platform which won’t have these restrictions on possible page types. As a result there is a need/desire to find all of the images which have been given a ‘fake’ flysheet label and correct this label with the correct label. . This is a task where computer vision seems like it might be helpful. . The desired outcome . The desire of this project is to be able to use a computer vision model to check a bunch of image directories and see if there are any ‘fake’ flysheets. There are some additional constraints on the project: . $$$ this isn’t a funded project so can’t involve spending a bunch of money | related to the above, the approach to annotation has to be pragmatic - no Mechanical Turk here | the machine learning should fit into existing workflows (this is something we have/are spending a lot of time on) | . Since this is intended to be a tl;dr I won’t go into more detail here about all of these requirements here. . flyswot . The approach we ended up with is to deploy a model using a command line tool that we’ve called flyswot. This tool can be pointed at a directory and it will recursively check for images which contain the fse pattern in the filename. These images are then checked using a computer vision model that looks check whether an image is a ‘real’ flysheet or a ‘fake’ flysheet. . What I have learned (so far) . This project has been a great way of turning some of the theory of ‘production’ ML into practice. In particular I have learned: . I’m super paranoid about domain drift. | (some) of how to use ONNX | More robust testing approaches | DVC (data version control) | and a bunch more things… | . Most of these things are being documented elsewhere and will be available to share at some point in 2022. However, I will try and use this blog to document small things I’ve learned along the way too. These notes are mainly for myself. There are a lot of little things I’ve picked up from doing this project that I will forget if I don’t spend a bit of time writting up. .",
            "url": "https://danielvanstrien.xyz/deployment/glam/flyswot/2021/12/22/flyswot.html",
            "relUrl": "/deployment/glam/flyswot/2021/12/22/flyswot.html",
            "date": " • Dec 22, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Full Stack Deep Learning notes on troubleshooting and debugging",
            "content": "Introduction to my notes . These are my notes from the full-stack deep learning course. . They have a focus on the GLAM setting, which might have different requirements, incentives and resources compared to business deployments of ML projects. These notes are for my use primarily. I am posting them to make myself more accountable for making semi-coherent notes. . These are my notes, written in a personal capacity - my employer denounces all my views . Why talk about debugging? . 80-90% of time spent on debugging? Useful to have some approaches for doing this work. . Why is deep learning debugging hard? . Small implementation details . Often you may get an error that results in weird results but the code still runs. You don’t have an exception to help you debug. Often need to manually dig around to find the cause of the error. Example: . images = glob.glob(&#39;path/to/images/*&#39;) labels = glob.glob(&#39;path/to/labels/*&#39;) . Will not return images and labels in the correct order because of how glob is implemented in python. This doesn’t throw an error but the model won’t learn anything. . Hyperparamers . Small changes to hyperparameters can make the difference between model training well and not training at all. . Data/Model fit . Performance on model on one set of images i.e. imagenet might not translate to the data you are working with. Transfer learning will often help but it might be unclear exactly how the model/new tasks translate to new types of data/problems. # . Models vs Dataset construction . In an academic setting, a lot of thought is given to choosing models/algorithms. Often this is less of a focus when deploying machine learning in a production setting where there will be many more challenges around constructing a dataset. . Notes: I think there is a shift here is going from training n a validation/training set to having in the back of your head that predictions will be made ‘in the wild’. . There can be a fair bit of variation in GLAM datasets which also potentially makes data drift hard to track . Architecture Selection . It can be overwhelming to pick between all the different types of model architectures. Suggestion to start out with a few different flavour and change if needed: . Type Model Maybe move to? . Images | LeNet-like model | ResNet | . Sequences | LSTM with one hidden layer | Attention | . other | Fully connected neural net with one hidden layer | Problem dependent | . Sensible defaults . version zero of your model could start with: . optimizer: Adam with learning rate 3e-4 | activations: relu (FC and Convultional models), tanh (LSTMS) | Intitilization: He et al. normal(relu), GLorot normal (tanh) | Regulirization: none | data normalization: none | . Consider simplifying the problem . start with a subset of the training data | use a fixed number of objects, classes etc. | create a simpler synthetic training set | . Model evaluation . tl;dr apply bias-variance decomposition . . In statistics and machine learning, the bias-variance tradeoff is the property of a model that the variance of the parameter estimates across samples can be reduced by increasing the bias in the estimated parameters. The bias-variance dilemma or bias-variance problem is the conflict in trying to simultaneously minimise these two sources of error that prevent supervised learning algorithms from generalising beyond their training set:[1][2] The bias error is an error from erroneous assumptions in the learning algorithm. High bias can cause an algorithm to miss the relevant relations between features and target outputs (underfitting). The variance is an error from sensitivity to small fluctuations in the training set. High variance can cause an algorithm to model the random noise in the training data rather than the intended outputs (overfitting). https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff . Test error = irreducible error + bias + variance + val overfitting | . Here we try and see the difference in error between our training data and some kind of baseline, i.e. human performance, to see how much we are underfitting. We also compare validation to training to see how much overfitting. . This assumes training, validation, and test come from the same distribution. . Notes: tracking the impact of distribution shift on model performance helpful here. . Example . Error source value . Goal | 1% | . Train error | 20% | . Validation error | 27% | . Test error | 28% | . The difference between our goal and our train error shows underfitting | The difference between train and validation also shows we’re also overfitting | test and validation error difference is okay | . 🤷‍♂️ Both overfitting and underfitting - how to decide what to do next… . prioritizing improvements . It seems hard to both deal with under and overfitting. The suggested process is to follow the following steps: . 1) address underfitting 2) address overfitting 3) address distribution shift 4) re-balance data (if applicable) . How to address under-fitting (i.e. reduce bias) . These suggestions are listed in order of what to try first. . Make the model bigger (i.e. resnet34, to resnet50) | reduce regulirization | error analysis | choose different model architecture (i.e. bump from LeNet to ResNet). This can introduce new problems, so be careful here | add features 😬 sometimes this can really help even in deep-learning | . Addressing over-fitting . add more training data (if possible) | add normalisation | data augmentation | regularisation | error analysis | choose better model architecture | tune hyperparameters | early stopping | remove features | reduce model size | . Addressing distribution shift . a) analyse test-val set errors - why might these errors be there in the validation set. b) analyse test-val set errors and synthesise more data c) domain adaptation . Error analysis . Try and find the different sources of error in test/val and see how easily they can be fixed + how much they contribute to the error. . This could be particularly important when domain expertise might help track down why some of these errors occur. This might also be used to reevaluate labels being targeted if they often cause confusion. Fastai has some nice methods for this most_confused to show which labels are often confused. If this confusion is reasonable, you may a) either not care too much about these mistakes b) collapse two labels into one label. . Domain adaptation . supervised: fine-tune pre-trained model | un-supervised: more in the research domain at the moment? | . Tuning Hypermaters . Model and optimiser choices? . how many layers | kernel size | etc. | . How to choose what to tune? some hyperparameters are more essential but its often hard to know which are going to be more important . rules of thumb of what is worth tuning . Hyperparamter likely senstivity . Learning rate | high | . Learning rate schedule | high | . Optimiser choice | low | . other optimiser parameters | low | . batch size | low (what fits onto GPU) | . weight initialisation | medium | . loss function | high | . model depth | medium | . layer size | high | . layer params | medium | . Weight of regularisation | medium | . nonlinearity | low | . Approaches to hyperparameters . Manual: . focus on what is likely to make a difference conceptually | train and evaluate model | guess a better parameters | can be good as a starting point + combined with other approaches | . Grid search . easy to implement | but expensive and you need to have a good sense of sensible range points | . Random search . often better than grid search for the same number of runs | not very easy to interpret | . Bayesian approaches . There are nice frameworks for doing this | generally most efficient t | can be hard to implement | . Overarching notes . personally, I think some of these suggestions might be better suited in settings where ml will be the product/service. In GLAMS, this might sometimes be the case, but there is also low hanging fruit using ml as a ‘tool’. In this case, I think it might make more sense to start with the proper implementation of ResNet as a starting point rather than coding your own net from scratch. . The discussion on error analysis was excellent and is a valuable framework for working out how to prioritise improvements. .",
            "url": "https://danielvanstrien.xyz/deployment/glam/2021/03/13/full-stack-deep-learning-lesson-7-debugging.html",
            "relUrl": "/deployment/glam/2021/03/13/full-stack-deep-learning-lesson-7-debugging.html",
            "date": " • Mar 13, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Full Stack Deep Learning notes on machine learning infrastructure and tools",
            "content": "Introduction to my notes . These are my notes from the full-stack deep learning course. . They have a focus on the GLAM setting, which might have different requirements, incentives and resources compared to business deployments of ML projects. These notes are for my use primarily. I am posting them to make myself more accountable for making semi-coherent notes. . These are my notes, written in a personal capacity - my employer denounces all my views . The Dream . The dream is to build a system that has a tight feedback loop between data -&gt; model -&gt; inference -&gt; more data -&gt; better model -&gt; better predictions … . One note here: this is a nice dream for some ml applications, but others might be more ‘one-off tools’ where this might be less important. For example, tools developed to help work with the ingest of a new collection. . Infrastructure buckets . A bunch of tools that help get closer to this dream broadly fall into three categories . Data Training Deployment . Data Sources | Compute | CI/CD | . Databases | Resource management | Testing | . Data Version control | Frameworks for distributed training | Tooling for edge deployment | . Labelling tools | Experiment management | Web deployment | . Feature stores | Hyperparmater tuning | monitoring | . There is a slightly overwhelming range of tools here. I think some of these only make sense at a certain level of scale, i.e. auto-scaling inference across multiple regions is probably not a scenario many (any?) glam institutions are dealing with at the moment for their ml pipelines. There are probably some notable exceptions here; internet archive, Wikipedia etc. . Editors . I fast forward through this bit as I’m mostly happy with my choices here! . Compute needs . Two primary compute needs: development and training/evaluation. . The development one intended to make experimentation easy. Do basic training etc. . Training compute: multi GPUs to do parameter sweeps etc. I think financial constraints often make this part less possible in a GLAM setting. There may also be some benefits to restricting compute slightly. Since GLAMs might (maybe should) be also considering how to share models approaches it migth not be helpful to immediately jump to models which require multiple GPUs to fine-train when a model with much more constrained resources might only be slightly worse. . Cloud vs local . Nvidia default for GPU | New architecture every year: Kepler -&gt; pascal -&gt; volta -&gt; turing -&gt; ampere | Server and then ‘enthusiast’, then consumer versions of the cards | Business only supposed to use primarily server cards. I don’t know what the definition of business is here, but it seems this is reguarly ignored | . A note here; I think a lot of use cases for deep learnings in GLAMs could probably be addressed with a dev box with one 3090 card and a bunch of storage. This may also be slightly less annoying for IT compared to going into the cloud. . The cost of cloud gets expensive compared to local deep learning rig. . Spot instances can make things cheaper. Can be fine for doing experiments in parallel and time saving is important. . On prem scaling can be challenging at some points. For a Glam lab setting having one/two GPUs still seems prefferable for ‘local work’ there might also be a desire to facilate access to collections for researhcers etc which may work better through the cloud. . Resource management . Managing environments, resources . could use simple scripts to manage this | slurm for scheduling jobs | docker - will come up later in the course | ‘all in one solutions’ - possibly overkill | . Frameworks . Deep learning frameworks put on a chart with good for production and good for development chart. . . I think in the context of using deep learning in a GLAM setting, there should be a lot of emphasis placed on using frameworks that focus on making things easier to understand for a broader audience. I think GLAMs should be trying to upskill a wide range of staff with some of the skills associated with ml and a core of staff with the skills to develop all/some/most things themselves as domain experts. For this, to work, I there needs to be an emphasis placed on the accessibility of model development. i.e. prefer to use a framework training loop (fastai/Keras/lightning) rather than roll a custom loop since this probably won’t add much but will often make code harder for others to understand. . Experiment tracking . Deep learning usually involves at least some experimentation with different model architectures, data augmentations, hyper parameters etc. Keeping track of this can be a pain to do manually. . Various options are available. Weights and Biases seem to be the most liked commercial offering. There are a bunch of open source projects that do this too. . Hyperparameter Optimization . Various options for doing this, including local/open source offerings. . Increasingly a move towards ‘end-to-end’ platforms for helping across the ml lifecycle. . My take away from this lecture is that there can be an overwhelming range of tools available. Probably these tools should be introduced slowly into a workflow. From my perspective, the experiment tracking components should be a priority. .",
            "url": "https://danielvanstrien.xyz/deployment/ethics/glam/2021/03/13/full-stack-deep-learning-lesson-6-tooling.html",
            "relUrl": "/deployment/ethics/glam/2021/03/13/full-stack-deep-learning-lesson-6-tooling.html",
            "date": " • Mar 13, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Full Stack Deep Learning notes on machine learning projects",
            "content": "Introduction to my notes . These are my notes from the full-stack deep learning course. . They have a focus on the GLAM setting, which might have different requirements, incentives and resources compared to business deployments of ML projects. These notes are for my use primarily. I am posting them to make myself more accountable for making semi-coherent notes. . These are my notes, written in a personal capacity - my employer denounces all my views . Lecture 5: Machine learning projects . This is the first ’proper’ lesson of the course with the previous ones focused on a review of deep learning approaches. This lecture focused on an overview of machine learning projects (beyond training a model) . 85% of machine learning projects fail . This stat might be a bit questionable in general but likely has some truth to it. How does this differ in a GLAM setting? It might be more evident in a business setting if a project is successful or not based on a business need. In a GLAM setting, a project that is never “deployed” might still by deemed successful. It is also my impression that there is a much closer overlap between academic/research projects and “business” projects in a GLAM setting. This might mean that the successful outcome is a published paper rather than a deployed model solving a “business” problem. . Lifecycle of a machine learning project . Covered in this lecture: . How to think about all of the activities in an ML project | Prioritising projects: what is feasible? | Archetypes: categories of projects and the implications for project management | Metrics: how to pick a single number to optimise | Baselines: how to know if a model is performing well | . Stages in the lifecycle are not linear but loop back and forth. i.e. you go back to project planning once you’ve started collecting data/labels because you realise the labels you collected aren’t feasible to collect. This might be more important in a GLAM setting? Data collection usually takes place in a different way; for example, I don’t know of any GLAMS that have extensively used paid crowdsource workers to collect training labels. This means that the label collection options might have to factor in more considerations around what is easy enough/fun enough. . Managing trade-offs between, e.g. accuracy and model latency . Cross-project infrastructure and staffing . Should there be a separate team? Where should they sit in an organisation? . Domain expertise is particularly important in a GLAM setting, so there might be risks with creating a team that does ML without this subject/domain expertise. On this point, I’m persuaded a lot by what fastai suggest about making deep learning accessible to domain experts. GLAMs should probably have some people who can support these efforts, but having a bunch of people hired as “the data science people” might be a bad idea if they don’t work closely with others across an institution. Maybe I’m naive here that GLAMs would be willing to invest in broad training of many staff rather than hiring a few people. 🤷‍♂️ . Prioritising machine learning projects . How to decide what a suitable candidate for an ML project is? . A (general) framework for prioritising projects . One way to identify projects is to try and find things that have a high impact and relatively low cost. . Mental models for high-impact ML projects . Four mental models introduced for thinking about impact: . Where can you take advantage of cheap prediction | Where is there friction in your product? | Where can you automate complicated manual processes? | What are other people doing? . | Cheap predictions (1) | For number 1, the idea of “cheap predictions” is useful even if the economics are different. Cheap predictions might be more about unlocking tasks that wouldn’t otherwise be possible to do. Rather than using ML to replace something, it might make it feasible to do something which otherwise would be too expensive for the relative benefit. . Where is there friction in your product? (2) | This objective seems important, but my examples of where GLAMS could make things easier for users would often not be simple projects to implement. They may also sit outside of what would be simple for a single institution to do on their own, or they may have already outsourced these systems. For example, cataloguing/discovery systems. . Where can you automate complicated manual processes? (3) | For number 3, I would adjust this slightly to “where can you automate simple/boring manual processes” I think this is an area where there is a bunch of low hanging fruit for GLAMs. It is tempting to jump to more jazzy end-to-end models that will fully revolutionise cataloguing etc., but there are loads of tasks that GLAM staff have to do that: . might be boring | are probably difficult to solve using “traditional” programming i.e. writing a rules-based system would be difficult | which has enough ’volume’ that it’s worth automating. | these are often also “staff facing” I think this reduced the potential risks of things going wrong versus something user-facing, for example, showing users a bunch of automatically generated tags for collection items? | . What is ML good at? . I think this is a lovely consideration. I also believe this is something where energy shoud be spent in spreading the gospel of what ML is good at to staff working in GLAMS. This will make it much easier for people to self diagnose that something they are working with could be a good candidate for ml to help with and also helps demystify. . The mental model of software 2.0 is a bit of a meme, but I think there is a lot of truth in there. The rules you would need to write to solve, for example, a relatively simple computer vision classification task, could be super complicated. Going back to my domain experts should use ml point: I think that there are places where ml could be used as a “tool” in a glam setting in a much more mundane way for much more modest things. The actual coding ability level is potentially lower for this than creating complex rules-based approaches to the same task. . | What are other people doing? . | This should be an obvious one and ideally this will become more feasible as GLAMS get better at collaborating on sharing code/data (particularly labelled training data). . An interesting point here about how to find out what others are doing. I think GLAMs are good at shouting about ML stuff at the moment because it’s super trendy. Still, there might be a lack of shouting about unsuccessful projects that others could learn from and/or shouting about more boring applications of ml that might be high impact but are not as obviously glamorous (pardon the pun). . Feasability . What drives the feasibility of a project? . Data availability . how much data do you need? | how stable is the data - if data updates in the real world all the time this will need to be replicated in the training data. This might be an argument for starting with more contained ’collections’ even if these collections are slightly arbitrary. | how secure does the data need to be. Copyright might be a challenge. GLAMs should push Text and Data Mining Exemptions more forcefully for machine learning projects | . | Accuracy requirements . how costly are wrong predictions? This obviously depends on the problem, but it might be an argument for starting with “staff facing” or “stand alone” projects where there is either more human checking involved or the system’s limitations can be made more explicit. | how frequently does the system need to be correct to be useful? | ethical implications of the model’s accuracy - what is the harm of a model getting things wrong. Particularly important if the accuracy is not evenly distributed. For example, using Named Entity Recognition across a multi-language dataset with accuracy much higher for English compared to other results. | pushing up accuracy tends to push up project costs because of more training data required, better label quality. | . | Feasibility of the method . What is still hard for ML? One rule of thumb suggested for what is possible with ml given: | . “Pretty much anything that a normal (sic) person can do in &lt;1 sec, we can now automate with ai” . Leaving aside the loaded “normal person” this rule doesn’t seem to work in many cases, as is pointed out in the lecture. There are a bunch of things that are easy for many people to do but aren’t easy at all for an ML system. Jokes, sarcasm etc. are all challenigng for ml. . Still challenging: . Pure unsupervised learning difficult | Reinforcement learning (outside of academia) | . | How to run a feasibility assessment? . Are you sure you need ML at all? Many problems can still be solved with regex… | Put in work up-front to define success criteria with all of the stakeholders: think this one is super important. It could be tempting to be a bit hazy on this and make the success criteria “we did a cool ml project”. This might be okay if the output is a paper/blog post but probably not if you’re going to deploy something into ’production’ | Consider the ethics: consider what weird/bad results commercial black box APIs might give with heritage data. Consider whether you are pilling onto existing biases in your collection. Some of the labels/metadata GALMS use/have used is shitty, so maybe don’t aim to get ml to produce even more of these… | Do a literature review | Try to rapidly build a labelled benchmark dataset | build a minimal product to see if the problem seems viable (not using ml) | . Machine learning product archetypes . Software 2.0 . examples: code completion, recomender systems etc. In a GLAM setting I gues this would incldue catlogues, disvoery systems, document summerization etc. . . Human-in-the-loop . Examples: turn sketches into slides, email auto-completion. In a GLAM setting, there are many potential examples, ML suggestions for cataloguing, document processing/classification/segmentation with some human review. . Autonomous systems . Examples: self driving cars etc. My 2 c is that most (maybe all) GLAM institutions don’t have sufficient experience with ML to really consider this. Exceptions may include robotics systems for some processes, but these are unlikely to be done “in house”. Maybe I am missing something here? . Data flywheel . sometimes you can get a positive feedback loop where you get more data -&gt; better model -&gt; more users - more data… . Things to consider. Where can this loop fail? The “more users” criteria might not translate in a glam setting, but perhaps building useful models/datasets that can then be extended on by other institutions is a similar positive feedback loop you can see. Transkribus is an example of this; they built a platform that got more data, which improved models that drove more people to consider it an option. . Product design . Principles from apple . How can you learn from your users? &lt;- This is super relevant! . Explicit feedback (suggest less pop music) | implicit feedback (like this song)+ calibration during setup (scan your face for FaceID) | corrections (fix model mistakes) &lt;- I think this is particularly important for successfully integrating into GLAM workflows and building trust that ML isn’t going to be making decisions without possibilities for correction | . How should your app handle mistakes? . limitations (let users) know where to expect the model to perform well/badly | corrections (let users succeed even if the model fails), i.e. don’t suggest labels that can’t be ignored | attribution (help users understand where suggestions come from) | confidence (help users gauge the quality of results) | . Metrics . How to pick a single number to optimise? . The real world is messy, and you often care about lots of metrics. If you need to compare models/approaches, its very helpful to have a single number to optimise. This can be done by combining different metrics. the optimisation can change as things improve. This single metric mindset is good for the model training part but should be balanced against other considerations as you move beyond this stage. . Common metrics to pick from . accuracy | precision | recall | . Don’t think we can generalise to saying one metric is more critical for glams, it really depends on the application. . Possible combinations weighted average between precision/recall. . More common in real-world is to use threshold n-1 metrics, evaluate to the nth. The idea here is that you pick one metric like accuracy to focus on but then try and improve that without making other things like the latency of the model much worse. This will be discussed more in future lectures. An example: you need a model that will fit into the memory of a particular edge device, so you start with something that will do this and optimise from there. . Choosing which metrics to the threshold . What should you optimise vs what should threshold? . Choosing metrics to threshold: . domain judgement: what can you engineer around? For example, maybe you can deal with a lower latency model by caching to get away with worse performance. In a glam setting, this will depend on the application, but if you are ’batch processing’ an existing collection you might not care about latency as much as if you are trying to use something which interacts with people in real-time, i.e. a cataloguing system. | which metrics are least sensitive to model choice? | which metrics are closest to desirable values. | . Choosing threshold values: . domain judgement - what is an acceptable tolerance downstream? | how well does a baseline model do? | how well does the model do already - if your model barely works, then its not going to be worth spending time trying to make it go faster… | . Once you have this baseline, you can eliminate models by successive metrics thresholds. i.e. first drop models with recall below n, then choose models which do well on precision given this minimal recall value. . It is important to try and be principled about which metric/combo you are going to use upfront as it will lead to different decisions being made about model choice etc. This might change, but its important to have something to drive decisions. . Baselines . Why? . Give you a lower bound for expected model performance | the tighter the lower bound, the more useful | . Having this baseline gives you some sense of how well/or crappy you are doing—otherwise its hard to make a judgement about next steps when training a model. . Where to look for baselines? | published results, make sure these are fair comparisons. | Scripted baselines e.g. rule-based approaches | could also use a simpler machine learning model as a baseline | or even take some kind of average of the dataset. sklearn has a bunch of dummy estimators useful for getting a baseline https://scikit-learn.org/stable/modules/model_evaluation.html#model-evaluation | . How to create good human baselines random people quality might be low | might require domain expertise | trainign people on the task can improve quality | ensembling of labels | . | Conclusion . ML lifecycle not linear | projects that are high impact and wrong predictions not so bad | secret sauce is to try and create automated data flywheels getting feedback from users of the model. much of this is about good product design | metrics: having a central metric is important as a starting point | baselines: help direct effort to know how the model is doing and where to direct energy | . suggested resources . https://stanford-cs329s.github.io/syllabus.html | https://developer.apple.com/design/human-interface-guidelines/machine-learning/overview/introduction/ | https://developers.google.com/machine-learning/guides/rules-of-ml/ | .",
            "url": "https://danielvanstrien.xyz/deployment/ethics/glam/2021/03/06/full-stack-deep-learning-glam-notes-5.html",
            "relUrl": "/deployment/ethics/glam/2021/03/06/full-stack-deep-learning-glam-notes-5.html",
            "date": " • Mar 6, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Writing a fastai callback",
            "content": "Intro . I sometimes feel like the process of me writing working code is analogous to the thing about monkeys writing Shakespeare, although in my case the end result of probably more like a Donald Trump tweet. My process for debugging or trying to work out how to implement something I&#39;m not completely familiar with seems to not always be efficient. This is something I&#39;m keen to work on. . This blog post is an attempt to try and do this &#39;in public&#39;. What I&#39;ve tried to do here is to use this blog post (which is also a notebook) as a place to record the steps I tried on the process of trying to implement a new callback in fastai. In particular I try and record my though process and the steps I took. This probably makes for an unreadable mess but I thought it might be useful as a record for myself. . This blog post isn&#39;t intended to be a guide on how to best solve a problem. It&#39;s more a cry for help 😂 . If anyone does read this, I would be really grateful to get any suggestions on: . whether you have suggestions to tackling a problem like this | if you think the &#39;come back to it later&#39; approach is sensible or not | . A callback to generate a rule of thumb about how much more data will help . I&#39;ve recently been doing a lot more annotation of data for various computer vision projects. Since I&#39;m doing all of the annotating myself I often want to have some sense of whether it is worth trying to get some more data. . Prodigy/Prodigy has a &#39;recipe&#39; for doing something that tries to answer this question. train_curve trains: . a model component with different portions of the training examples and print the accuracy figures and accuracy improvements with more data. This recipe takes pretty much the same arguments as train. --n-samples sets the number of sample models to train at different stages. For instance, 10 will train models for 10% of the examples, 20%, 30% and so on. This recipe is useful to determine the quality of the collected annotations, and whether more training examples will improve the accuracy. As a rule of thumb, if accuracy improves within the last 25%, training with more examples will likely result in better accuracy. Source There is also a nice example of this in action in this youtube video . . I wanted to implement something similar in fastai. My stretch goal was to make something that would be useful enough and be implemented cleanly enough that I could make a pull request to fastai proposing this. I am not sure if this will actually get there but I wanted to have this in mind as an end goal so that I: . force myself to not take hacky shortcuts | force myself to be exposed to more of the inner functionality of fastai | learn about the callbacks system in a lot more detail | . Regarding the second point, I am particularly keen to do this &#39;inside&#39; fastai rather than &#39;wrapping&#39; something around fastai. If you are familiar with callbacks already this distinction will probably be clear already. If not, hopefully it will make sense later. . Part 1... . This part goes through most of the steps I took, some of the notebook has been tidied so it&#39;s not even longer than this will already be... . from fastai.vision.all import * from fastai.callback import * from fastai.test_utils import * import pandas as pd . Dynamically altering the training data size . What I want to be able to do is to dynamically alter the training data. i.e. modify the data attached to a learner dynamically rather than recreating the dataloaders outside of the training loop. Try to do this with example data . #hide_show data = untar_data(URLs.IMAGEWANG_160) dls = ImageDataLoaders.from_folder(data/&#39;train&#39;, valid_pct=0.7, item_tfms=[Resize(64)]) len(dls.dataset) . I think train_ds is probably the the thing I want to modify . dls.train_ds . (#4401) [(PILImage mode=RGB size=213x160, TensorCategory(8)),(PILImage mode=RGB size=213x160, TensorCategory(16)),(PILImage mode=RGB size=213x160, TensorCategory(6)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=202x160, TensorCategory(14)),(PILImage mode=RGB size=240x160, TensorCategory(18)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=160x457, TensorCategory(17)),(PILImage mode=RGB size=240x160, TensorCategory(19)),(PILImage mode=RGB size=160x240, TensorCategory(8))...] . learn = cnn_learner(dls, squeezenet1_0, metrics=accuracy, pretrained=False) learn.fit(1) . epoch train_loss valid_loss accuracy time . 0 | 3.584931 | 3.637918 | 0.131671 | 01:05 | . I think it will probably be safer to make a deepcopy of things. . import copy . . Note: I&#8217;m not quite sure whether this is the best way of handling this, it seems to be very hacky. . d_original = copy.deepcopy(learn.dls.dataset) d_original . (#4401) [(PILImage mode=RGB size=213x160, TensorCategory(8)),(PILImage mode=RGB size=213x160, TensorCategory(16)),(PILImage mode=RGB size=213x160, TensorCategory(6)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=202x160, TensorCategory(14)),(PILImage mode=RGB size=240x160, TensorCategory(18)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=160x457, TensorCategory(17)),(PILImage mode=RGB size=240x160, TensorCategory(19)),(PILImage mode=RGB size=160x240, TensorCategory(8))...] . Grab a smaller part of the dataset . len(dls.dataset) * 0.5 . 2200.5 . Pass this back in. . learn.dls.dataset = L(dls.dataset[:100]) . learn.dls.dataset . (#100) [(PILImage mode=RGB size=213x160, TensorCategory(8)),(PILImage mode=RGB size=213x160, TensorCategory(16)),(PILImage mode=RGB size=213x160, TensorCategory(6)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=202x160, TensorCategory(14)),(PILImage mode=RGB size=240x160, TensorCategory(18)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=160x457, TensorCategory(17)),(PILImage mode=RGB size=240x160, TensorCategory(19)),(PILImage mode=RGB size=160x240, TensorCategory(8))...] . learn.fit(5) . epoch train_loss valid_loss accuracy time . 0 | 3.035343 | 2.480581 | 0.215037 | 01:04 | . 1 | 2.913207 | 2.479565 | 0.212115 | 01:01 | . 2 | 2.817269 | 2.409176 | 0.240066 | 01:05 | . 3 | 2.696751 | 2.442177 | 0.211044 | 01:02 | . 4 | 2.664056 | 3.162136 | 0.254967 | 01:04 | . check our data again, (I&#39;m paranoid) . learn.dls.dataset . (#100) [(PILImage mode=RGB size=213x160, TensorCategory(8)),(PILImage mode=RGB size=213x160, TensorCategory(16)),(PILImage mode=RGB size=213x160, TensorCategory(6)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=202x160, TensorCategory(14)),(PILImage mode=RGB size=240x160, TensorCategory(18)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=160x457, TensorCategory(17)),(PILImage mode=RGB size=240x160, TensorCategory(19)),(PILImage mode=RGB size=160x240, TensorCategory(8))...] . Now try and shove in the original data. . learn.dls.dataset = d_original . learn.dls.dataset . (#4401) [(PILImage mode=RGB size=213x160, TensorCategory(8)),(PILImage mode=RGB size=213x160, TensorCategory(16)),(PILImage mode=RGB size=213x160, TensorCategory(6)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=202x160, TensorCategory(14)),(PILImage mode=RGB size=240x160, TensorCategory(18)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=160x457, TensorCategory(17)),(PILImage mode=RGB size=240x160, TensorCategory(19)),(PILImage mode=RGB size=160x240, TensorCategory(8))...] . check that this fit still . learn.fit(1) . epoch train_loss valid_loss accuracy time . 0 | 2.512241 | 2.247095 | 0.284184 | 01:02 | . learn.dls.dataset . (#4401) [(PILImage mode=RGB size=213x160, TensorCategory(8)),(PILImage mode=RGB size=213x160, TensorCategory(16)),(PILImage mode=RGB size=213x160, TensorCategory(6)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=202x160, TensorCategory(14)),(PILImage mode=RGB size=240x160, TensorCategory(18)),(PILImage mode=RGB size=213x160, TensorCategory(15)),(PILImage mode=RGB size=160x457, TensorCategory(17)),(PILImage mode=RGB size=240x160, TensorCategory(19)),(PILImage mode=RGB size=160x240, TensorCategory(8))...] . This seemed to work with a few attempts but it seemed like a bad idea. I asked if anyone could see if this was an issue in the fastai discord . I kind of felt unsure about how best to approach the data issue so for now I&#39;ll move on to playing around with the callbacks. . . Warning: this seemed like a bad idea (spoiler alert it was. I&#8217;ll come back to this later... . Using callbacks . Since I&#39;m not completely sure about how to approach the dynamic resizing of data I&#39;ll move on to getting stuck into the callbacks and coming back to this issue later. . I&#39;m not sure if moving on when I get stuck is the best approach. I feel like I sometimes end up trying to &#39;brute force&#39; a solution at some point rather thanking thinking it through carefully. I feel like coming back to it later sometimes helps but it could also be kicking the can down the road... . How to use callbacks basics . First when can where can a call back be used? The docs for the callbacks gave me a good starting point. One of the things I need to work out is where callbacks can be called, the second where I would want to use callbacks in this example. . The callbacks can helpfully be found under event . [e for e in dir(event) if not e.startswith(&#39;__&#39;)] . [&#39;after_backward&#39;, &#39;after_batch&#39;, &#39;after_cancel_batch&#39;, &#39;after_cancel_epoch&#39;, &#39;after_cancel_fit&#39;, &#39;after_cancel_train&#39;, &#39;after_cancel_validate&#39;, &#39;after_create&#39;, &#39;after_epoch&#39;, &#39;after_fit&#39;, &#39;after_loss&#39;, &#39;after_pred&#39;, &#39;after_step&#39;, &#39;after_train&#39;, &#39;after_validate&#39;, &#39;before_backward&#39;, &#39;before_batch&#39;, &#39;before_epoch&#39;, &#39;before_fit&#39;, &#39;before_train&#39;, &#39;before_validate&#39;] . Maybe we want to do our setup before fit? . My first though is that it was likely that I would want to do some stuff before fitting so I wanted to start here. The other things which the docs page helped is in understanding the attributes available using callbacks. To get more familiar I&#39;ll try printing out some of these attributes. This will hopefully also clarify they are what they think I are. . class ShowTrainInfo(Callback): def before_fit(self): print(f&quot;Number of Epochs:{self.n_epoch}&quot;) . This (hopefully) will print out the number of epochs before the model fit . learn.fit(1, cbs=ShowTrainInfo()) . Number of Epochs:1 . epoch train_loss valid_loss accuracy time . 0 | 2.478273 | 2.763863 | 0.145014 | 01:04 | . This seems to work! Try to do something a bit closer to what I want to achieve... . One thing that I need to be able to do is manipulate the number of epochs. I want to basically run the epochs passed by the user multiple times with different subsets of the data. This will simulate running the training loop multiple times inside the training loop. . Maybe it&#39;s easier to call after_create so that instead of having to try and capture all of the info about the learner and recreating it we do the following: . after create: . multiply the number of epochs by the number of &#39;trials&#39; (maybe with some added options later e.g. early stopping, terminate on NaN) | create first trial using (len(fulldata))/number of trials i.e. for 4 trials get 25% of data | pass first trial data to model | train model | if epoch number % epochs per trial==0: record the information about best result, last result etc. | reset the model weights | create new updated size of training data i.e. next step for 4 trials = 50% | ? not sure how to best record that this is a different trial and record other info -&gt; maybe store in an attribute of the callback? | ? not sure about what the log/print at the end, will do some baby print statements for now, this is obviously where I want to sink loads of time into choosing emojis to print... | . | . Try out the manipulation of the number of epochs. I think it should be possible to just update this value. I&#39;ll do it in before_fit for now. . class ShowTrainInfo(Callback): def before_fit(self): print(self.n_epoch) self.learn.n_epoch *=4 . learn.fit(1, cbs=ShowTrainInfo()) . 1 . . 100.00% [1/1 01:01&lt;00:00] epoch train_loss valid_loss accuracy time . 0 | 2.445697 | 2.376423 | 0.281457 | 01:01 | . . 100.00% [161/161 00:27&lt;00:00 2.3999] . 200.00% [2/1 02:06&lt;-1:58:57] epoch train_loss valid_loss accuracy time . 0 | 2.445697 | 2.376423 | 0.281457 | 01:01 | . 1 | 2.399856 | 2.251869 | 0.281457 | 01:04 | . . 100.00% [161/161 00:27&lt;00:00 2.3335] epoch train_loss valid_loss accuracy time . 0 | 2.445697 | 2.376423 | 0.281457 | 01:01 | . 1 | 2.399856 | 2.251869 | 0.281457 | 01:04 | . 2 | 2.333455 | 2.175574 | 0.308142 | 01:01 | . 3 | 2.291610 | 2.286107 | 0.277854 | 01:04 | . Is this actually training four times? The progress bar makes things a little tricky to read. Let&#39;s print out the epochs to check, and get rid of the progress bar for now so it&#39;s easier to see what&#39;s going on . class ShowTrainInfo(Callback): def before_fit(self): print(f&quot;number epochs passed by user:{self.n_epoch}&quot;) self.learn.n_epoch *=4 def after_epoch(self): print(f&quot;just finished epoch:{self.epoch}&quot;) . with learn.no_bar(): learn.fit(1, cbs=ShowTrainInfo()) . number epochs passed by user:1 [0, 2.2561960220336914, 2.186687469482422, 0.31038177013397217, &#39;01:02&#39;] just finished epoch:0 [1, 2.263982057571411, 3.9907848834991455, 0.2859368920326233, &#39;01:03&#39;] just finished epoch:1 [2, 2.234278917312622, 2.299966812133789, 0.3186599016189575, &#39;01:04&#39;] just finished epoch:2 [3, 2.1652183532714844, 2.047651529312134, 0.36112192273139954, &#39;01:26&#39;] just finished epoch:3 . That seems to be okay, we have 4 total epochs. I&#39;ll get back to the logging issue later... . Let&#39;s try the idea of breaking for each point in the trial i.e in this case after each epoch. Maybe should also add an init to the callback and give it a more sensible name. I will also now add something that will &#39;reset&#39; the model after each trial. i.e. after the original epochs passed by the user. For now, I&#39;ll just add some print statements to see where things are being called. I&#39;m hoping this will let me confirm I&#39;m planning to execute callbacks in the right place. . class DSetSizeTrials(Callback): def __init__(self, n_trials=4): self.n_trials = n_trials def before_fit(self): self.epoch_per_trial = self.n_epoch print(f&quot;number epochs passed by user:{self.n_epoch}&quot;) self.learn.n_epoch *=self.n_trials def after_epoch(self): print(f&quot;just finished epoch:{self.epoch}&quot;) if (self.epoch+1) % self.epoch_per_trial==0: print(&#39;reset model&#39;) . with learn.no_bar(): learn.fit(3, cbs=DSetSizeTrials(2)) . number epochs passed by user:3 [0, 2.108391761779785, 3.002286672592163, 0.30103233456611633, &#39;01:22&#39;] just finished epoch:0 [1, 2.0375003814697266, 2.582606792449951, 0.2694779932498932, &#39;01:09&#39;] just finished epoch:1 [2, 2.0219476222991943, 2.2244386672973633, 0.3190494775772095, &#39;01:15&#39;] just finished epoch:2 reset model [3, 1.9379000663757324, 2.5143325328826904, 0.37748345732688904, &#39;01:04&#39;] just finished epoch:3 [4, 1.939262866973877, 2.207705020904541, 0.33180755376815796, &#39;01:07&#39;] just finished epoch:4 [5, 1.894189715385437, 10.37093448638916, 0.3005453944206238, &#39;01:04&#39;] just finished epoch:5 reset model . I&#39;m not limited by my own brain... . Getting back to the issue of whether passing in a new subset of data by doing learn.dls.dataset = L(dls.dataset[:100]) was a bad idea. It turns out it was. Although this worked without issue for the first dataset I worked with when I tried with data loaded via a DataFrame I got errors even at the indexing stage. Since I had asked the question in the discord I thought it was worth responding: . . My initial response wasn&#39;t super helpful in hindsight. Saying something is a bad idea isn&#39;t very useful for anyone else. This is often super obvious when you see someone else do it but I think it&#39;s easy to forget. One of the things I love about fastai is the community around it which is super focused on helping people out. I&#39;m glad Zach asked followed up here since this exchange also ended up being super useful. My follow up reply: . For context, what I am trying to work out is how to dynamically change my training data size during training, i.e. first use 25%, then 50% of the training data. I thought this might be possible by indexing the dls.dataset attribute and updating it to a slice of that. This worked out when the original dataloaders was defined via a from_folder. When I just tried the same thing using a dls originally created via a DataFrame I get a FileNotFoundError. I&#39;m still trying to wrap my head around exactly why one works but not the other, but I&#39;m assuming that the dataset attribute doesn&#39;t contain all the information that is needed to get to an item in all cases? . . Tip: Say both what you are trying to do and why you are trying to do something. This gives a much better insight for people who might want to help. . Although my response doesn&#39;t say exactly what is going wrong it offer my best guess and also gives some insight into my motivations. In this case since it seems like a slightly weird thing without the wider context/motivations outlined above. . . This led to a super helpful exchange with a few people in the discord which honed in on a few possible solutions to this problem. . . I don&#39;t want to reproduce the whole exchange but what was super nice is that: . a bunch of people tried to help. Even if nothing else it gives you warm fuzzies that people are happy to help you with this kind of thing | people offered a bunch of different approaches all of which offered potential things for me to follow up | this fast tracked my progress, particularly since it might have got super annoying to be stuck on this problem on my own for ages. | . . Tip: other people are happy to help but you should try and make it easy for them to help you (and I should reciprocate where I can) . Following this input from other people I followed up on shuffle_fn as a way to achieve what I&#39;m trying to do (inside of a callback). Again, I&#39;ll try modifying this outside of a callback to see how it works . dls = ImageDataLoaders.from_folder(data/&#39;train&#39;, valid_pct=0.3, item_tfms=[Resize(64)]) . dls.train_ds . (#10269) [(PILImage mode=RGB size=239x160, TensorCategory(19)),(PILImage mode=RGB size=160x240, TensorCategory(19)),(PILImage mode=RGB size=160x357, TensorCategory(17)),(PILImage mode=RGB size=213x160, TensorCategory(19)),(PILImage mode=RGB size=290x160, TensorCategory(0)),(PILImage mode=RGB size=213x160, TensorCategory(17)),(PILImage mode=RGB size=160x213, TensorCategory(17)),(PILImage mode=RGB size=160x263, TensorCategory(9)),(PILImage mode=RGB size=213x160, TensorCategory(14)),(PILImage mode=RGB size=213x160, TensorCategory(18))...] . Looking at what it does at the moment . ??dls.train.shuffle_fn . Signature: dls.train.shuffle_fn(idxs) Docstring: Returns a random permutation of `idxs`. Source: def shuffle_fn(self, idxs): return self.rng.sample(idxs, len(idxs)) File: /usr/local/anaconda3/envs/blog/lib/python3.8/site-packages/fastai/data/load.py Type: method . We can easily patch the functionality, in this case we&#39;ll just return 128 items . @patch_to(DataLoader) def shuffle_fn(self, idxs): return self.rng.sample(idxs, 128) . Check this has changes as expected . ??dls.train.shuffle_fn . Signature: dls.train.shuffle_fn(idxs) Docstring: &lt;no docstring&gt; Source: @patch_to(DataLoader) def shuffle_fn(self, idxs): return self.rng.sample(idxs, 128) File: ~/Documents/daniel/blog/_notebooks/&lt;ipython-input-29-99a68b7fe249&gt; Type: method . Now try training... . learn = cnn_learner(dls, squeezenet1_0) learn.fit(1) . epoch train_loss valid_loss time . 0 | 4.615644 | 6.038196 | 00:17 | . This seemed to do the training step very quickly so it&#39;s probably only getting 128 items but I don&#39;t know that for sure. If only there was some way of getting access to the training loop in fastai 😜 . class PrintItems(Callback): def __init__(self): self.items_done = 0 def after_batch(self): print(self.iter) self.items_done += (max(self.iter,1)* self.learn.dls.bs) def before_validate(self): print(self.items_done) raise CancelFitException(&#39;stopped before valid&#39;) . learn.fit(1, cbs=PrintItems()) . epoch train_loss valid_loss time . 0 | 4.113161 | None | 00:00 | . 0 1 128 . With some more guidance I update this function to accept an input parameter that we can then easily update during training. . @patch def my_shuffle_fn(self:DataLoader, idxs, size=128): return self.rng.sample(idxs, size) . from functools import partial . dls.train.shuffle_fn = dls.train.my_shuffle_fn . ??dls.train.shuffle_fn . Signature: dls.train.shuffle_fn(idxs, size=128) Docstring: &lt;no docstring&gt; Source: @patch def my_shuffle_fn(self:DataLoader, idxs, size=128): return self.rng.sample(idxs, size) File: ~/Documents/daniel/blog/_notebooks/&lt;ipython-input-34-95358dde961e&gt; Type: method . Defining roughly what I want to do with some print statements again... . class PrintItems(Callback): def __init__(self): self.items_done = 0 def before_train(self): print(&#39;calculating partial data sizes...&#39;) print(&#39;updating shuffle_fn....&#39;) self.learn.dls.train.shuffle_fn = partial(self.learn.dls.train.my_shuffle_fn, size=128) def after_batch(self): print(self.iter) self.items_done += (max(self.iter,1)* self.learn.dls.bs) def before_validate(self): print(self.items_done) raise CancelFitException(&#39;stopped before valid&#39;) . learn.fit(1, cbs=PrintItems()) . epoch train_loss valid_loss time . 0 | 2.966318 | None | 00:00 | . calculating partial data sizes... updating shuffle_fn.... 0 1 128 . To be continued... . To avoid this becoming even longer I&#39;ll pick up the next steps of trying to get this callback working in another blog post. . Summary so far . How this doing this help with my original goals. . I&#39;ve definitely got a much better grasp on the callback system in fastai. Even though the specific callback I&#39;m working on is still a work in progress, I now know much better where the entry points for callbacks are and what can be accessed/modified. I would feel more confident implementing callbacks than before. . | my &#39;process&#39; is still a work in progress but having in mind that I should try and record the steps was actually super helpful and something I&#39;ll try and do better next time. . | Asking other people for help can move progress forward quickly. I think there is a skill in asking questions in the best way possible and this is something I&#39;ll continue to work on... . | .",
            "url": "https://danielvanstrien.xyz/fastai/callbacks/learning/2021/03/04/callbacks-and-debugging-part-one.html",
            "relUrl": "/fastai/callbacks/learning/2021/03/04/callbacks-and-debugging-part-one.html",
            "date": " • Mar 4, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "Power, Ethics and AI for GLAMs",
            "content": "This is a very quick rambling post on ethics/power and ai in a GLAM setting. . On a recent(ish) call for the fastai4fglams study group we discussed Lecture 5 of the fast.ai course which focuses on Ethics. . A question we discussed in the call was about the more specific ethical issues that could emerge when using AI in a library context. . Some of the topics we touched on in the discussion included: . The Provenance of collection items | How this provenance is represented (or not) in metadata | The use of Black Box commercial solutions for working with GLAM data | The alternatives (or lack of) to using machine learning for some tasks | How much to document the provenance of a label produced by ml | . How to present labels produced via machine learning . I should preface this discussion by saying I am not an expert in cataloging or the associated literature. . Instead of trying to cover all of these issues I will focus on one particular question for GLAMs using machine learning: how to display the labels produced by these models in library systems i.e. catalogues? . One of the main uses cases of Machine Learning models is to produce labels for collections items. These labels could either seek to ‘augment’ or ‘replace’ existing metadata records fields. A question for either of these is how to display, store and manage labels produced via machine learning models in library systems. For example a model which is trained to predict the year field for items in a particular collection. . The model . Knowing the model which produced a label including: . the architecture | the year in which the model was trained/inference made | version of the model | … | . There is a danger of replicated the granularity of tools like Weights and Biases. Whilst this information is useful for training and provenance for people familiar with machine learning methods, some of the information in these systems is going to be less relevant for a typical library catalog user e.g. GPU memory consumption during training. There are potentially some other fields which will be more relevant to a broader number of people. . Possible labels . The first question for this type of task might be to know how the original model task was defined. Predicting labels for ‘year’ could be treated as a classification task. For example if you have a collection where you a certain that all items in that collection will have been produced between certain dates the task may be to predict classify whether the item belong to the 80s or 50s decade. In this case the model has a restricted range of possible outputs i.e. each decade in the original training data. . Another approach would be to instead make this a ‘regression’ task, where the model predicts a continuous value. In this case the model is not bound by a particular set of possible years. . The distinction between a classification and a regression model, and the possible bound of values for a label might give the end-user of that label a better sense of how it should be ‘read’. Using this information will also provide some way of contextualizing the confidence of the label, and what this might mean. An F1 score will mean different things if a model had to choose between one five possible decades for a year label or choose one of a 100 possible years. . Alongside knowing the potential labels, it may be useful for a user of a catalog to know something about the distribution of these labels i.e. how many times does a certain label appear both during the inference and training steps. . Training data . Having at least a minimal way of interrogating the original training data could allow for more interrogation of models even by those who aren’t experts in machine learning and in fact domain experts might pick up on important features of a training dataset that might have been missed during it’s construction. Including some information about: . number of training examples | label distribution | min, max values | etc. | . Ideally this dataset would be available for open use by others but this might not always be possible for collections which aren’t fully open. . How to present this information? . To be continued… .",
            "url": "https://danielvanstrien.xyz/fastai%20course/ethics/2020/11/05/power-ethics-and-ai-in-glams.html",
            "relUrl": "/fastai%20course/ethics/2020/11/05/power-ethics-and-ai-in-glams.html",
            "date": " • Nov 5, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Image labeling vs classification models",
            "content": "The &#39;hello world&#39; example for introducing deep learning based computer vision often involves classifying images as 🐶 or 🐱. An alternative approach to classifying images is to instead apply labels. This is usually introduced in the context of multi-label classification i.e. where an image can have more than one label. In this blog post I discuss some of the differences between these two approaches, specifically the difference in loss functions, and how these two approaches might work better depending on the application. The post starts with a conceptual overview of the differences between these two approaches, before showing the different loss functions and then moving to a practical example of training these two different types of model. . Image Classification vs Image Labeling . In a classification model, an input can have only one label. This could be one of a few or one of a hundred, regardless of the number of potential classes, it is assumed that the input only belongs to one of these. With a model that applies labels this is not true an input can have one, multiple or no labels. . Sorting through family photos . We can use an analogy to illustrate the difference between these two approaches. Let&#39;s say you were sorting through some old family photographs. You might &quot;classify&quot; the photos into one (and only one) of two photo albums, depending on whether they are black-and-white or colour. This would be comparable to using a classification model since each photo will go into exactly one of these two albums - a photo cannot be both simultaneously colour and black-and-white, and it cannot be neither colour nor black-and-white. . You may at the same time also want to make it easier to find photos of particular people in your family. You could do this by assigning labels to each photo, indicating or &quot;tagging&quot; the family members who appear in the photo. In this case, a photo may have one label (a photo of your sister), more than one label (a photo of your sister and aunt), or it may have no labels (a photograph of a landscape taken on a holiday). This would be analogous to a multi-label classification model. . The choice between using a model which performs classification or a model which assigns labels should be considered in relation to the role your model has. It is also useful to look a little bit more closely as how these different types of models work under the hood. . CrossEntropyLoss vs BCEWithLogitsLoss . When we create a model which does classifications or applies labels, the distinction, if using the same data is that they use different loss functions. . A classification model will use a variant of Cross Entropy Loss whilst the label model will use a BCE with Logits Loss. We&#39;ll see how this is inferred by fastai below but fore now take my word for it... . Let&#39;s take a look at a snippet of the Pytorch docs for each of these loss functions . CrossEntropyLoss . This criterion combines nn.LogSoftmax() and nn.NLLLoss() in one single class. It is useful when training a classification problem with C classes. If provided, the optional argument weight should be a 1D Tensor assigning weight to each of the classes. This is particularly useful when you have an unbalanced training set. Read more . BCEWithLogitsLoss . This loss combines a Sigmoid layer and the BCELoss in one single class. This version is more numerically stable than using a plain Sigmoid followed by a BCELoss as, by combining the operations into one layer, we take advantage of the log-sum-exp trick for numerical stability. Read more . Let&#39;s see what these do to some activations. First we&#39;ll import required packages . import torch.nn as nn import numpy as np import torch . Exploring CrossEntropyLoss . We can create some fake activations. To start we&#39;ll just consider one output with three classes. We&#39;ll start with one to keep things simple for now. . one_act = torch.randn((1, 3)) * 1 one_act . tensor([[ 0.9924, 0.8698, -0.0100]]) . We can think of these activations as probabilities for one of three classes. Let&#39;s see what these sum to. . one_act.sum() . tensor(1.0875) . We can see that these activations don&#39;t sum to 1. If we want our image input to belong to only one class, then the labels are not mutually exclusive of each other i.e. if one label probability is higher, another needs to be lower i.e. the probabilities need to add up to 1. Going back to the Pytorch explanation of CrossEntropyLoss we see that one component is nn.LogSoftmax(). What is particularly relevant here is that &#39;softmax&#39; part. Let&#39;s see what this does to our activation . softmax_acts = torch.softmax(one_act, dim=1) softmax_acts . tensor([[0.4525, 0.0381, 0.5093]]) . You can probably already see how this has changed the nature of these activations. Let&#39;s call sum on these outputs again. . softmax_acts.sum() . tensor(1.) . We now have a sum of 1! We can now treat this as the probability of an input image belonging to a particular class. We could then call argmax to find out which class the model is most confident about and use that as our prediction. . softmax_acts.argmax(dim=1) . tensor([2]) . One of the potential issues that was mentioned about using a classification model was that it doesn&#39;t account for ambiguities in the labels very well. . What is softmax doing? . Digging into what softmax does in a little bit more detail will show what is going on here. . First lets see what softmax actually does, I&#39;ll skip the LaTeX formula from Wikepedia because it makes is look much scarier than the Python code example: . a = [1.0, 2.0, 3.0, 4.0, 1.0, 2.0, 3.0] np.exp(a) / np.sum(np.exp(a)) . array([0.02364054, 0.06426166, 0.1746813 , 0.474833 , 0.02364054, 0.06426166, 0.1746813 ]) . This is much easier for me to parse compared to the Greek. Let&#39;s look at the different parts. Working with one set of activations again: . one_act . tensor([[ 1.1479, -1.3265, 1.2661]]) . Starting from np.exp(a) we can do this in Pytorch like: . one_act.exp() . tensor([[3.1515, 0.2654, 3.5471]]) . We can convert the rest of the numpy code as follows . one_act.exp().sum(dim=1) . tensor([6.9641]) . Putting it all together we get . (one_act.exp() /one_act.exp().sum(dim=1)).sum(dim=1) . tensor([1.]) . This seems to work as expected, i.e. we get the probabilities to sum to 1. To make it clearer what&#39;s going on though, it&#39;s useful to look a little more closely at the difference using exp makes. Let&#39;s import the standard python version of exp and check the docs. . from math import exp doc(exp) . exp[source] . exp(x) . Return e raised to the power of x. . What difference does using the exponent make? We&#39;ll use a simple array of values to keep things simple . x = np.array([1,2,4,1]) x . array([1, 2, 4, 1]) . Now if we want these to be converted to probabilities for different classes we need them to sum to 1. We could just do this by dividing each element by the sum. . x/x.sum() . array([0.125, 0.25 , 0.5 , 0.125]) . We can confirm this add to 1 . (x/x.sum()).sum() . 1.0 . Now this seems to work to get us probabilities for each class. Let&#39;s compare doing the same thing but using exp to create exponents of the inputs . np.exp(x)/np.sum(np.exp(x)) . array([0.04031637, 0.10959126, 0.80977599, 0.04031637]) . Again we get an array of probabilities, let&#39;s confirm they add to one. . one_act.exp()/one_act.exp().sum(dim=1) . tensor([[0.4441, 0.3929, 0.1630]]) . So what is different here? . Let&#39;s put the two arrays next to each other so we can compare the values for each index . np.exp(x)/ np.sum(np.exp(x)), (x/ x.sum()) . (array([0.04031637, 0.10959126, 0.80977599, 0.04031637]), array([0.125, 0.25 , 0.5 , 0.125])) . Other than the difference in decimals, you will probably notice that when we use exponent, some labels for a class have been pushed much higher. Index 2 is 0.80 when we use exp and only 0.5 when we don&#39;t use the exponent. This is an important difference here. By using the magic properties of $e$ we &#39;push&#39; one probability to be higher than the others. . This property is useful when we have a clear distinction between classes. If we were predicting handwritten digits there (should) only be one correct answer. In this case having one class prediction being pushed much higher would be a good thing. . If however, we have labels which are more ambiguous, this would be less of a desirable property. Even if we try and capture ambiguity by using the raw probabilities of the labels, rather than taking the argmax value, the numerical properties of the softmax function mean that it likely that one label value will be pushed higher than the others. . We&#39;ll look at a practical example later on to illustrate this. Let&#39;s now quickly compare our other loss function . Exploring BCEWithLogitsLoss . As a reminder . This loss combines a Sigmoid layer and the BCELoss in one single class. . The part here that we are particularly interested in is the Sigmoid. Let&#39;s use one_acts again . one_act . tensor([[ 1.1479, -1.3265, 1.2661]]) . As a reminder sigmoid function can be plotted as . You&#39;ll probably be familiar with sigmoid as one of the potential activations functions you can use in the a neural network. The property we care about is that it squishes inputs into a value between 0 and 1. Let&#39;s do this for our activations . torch.sigmoid(one_act) . tensor([[0.7591, 0.2097, 0.7801]]) . We can see that all our values have been pushed between 0 and 1. However, we can also see they don&#39;t sum to 1. . torch.sigmoid(one_act).sum() . tensor(1.7489) . What we have here is a probability for each label which is independent of the probability of the other labels. The sigmoid function makes sure the activations for each label becomes a probability but it doesn&#39;t make sure that all of the labels probabilities sum to 1. Looking at a practical example using fastai might illustrate this difference. . We&#39;ll work with some images taken from 19th Century books, the specific images in this case don&#39;t matter to do much . We&#39;ll import fastai and then put images from two folders &#39;building&#39; and &#39;coat&#39; into a Pandas DataFrame. . from fastai.vision.all import * . files = get_image_files(&#39;data/cv_workshop_exercise_data/&#39;, folders=[&#39;building&#39;, &#39;coat&#39;]) df = pd.DataFrame(files.items, columns=[&#39;fname&#39;]) df[&#39;class_label&#39;] = df[&#39;fname&#39;].apply(lambda x: x.parts[2]) df[&#39;class_label&#39;].value_counts() . building 44 coat 26 Name: class_label, dtype: int64 . We can see we have two possible classes building and coat. First we&#39;ll load these into fastai as a classification model. . dls_classification = ImageDataLoaders.from_df(df,fn_col=&#39;fname&#39;,valid_pct=0.4, label_col=&#39;class_label&#39;, item_tfms=Resize(128, ResizeMethod.Squish), bs=8,num_workers=0) . dls_classification.show_batch() . You&#39;ll see that building refers to a building, whilst a coat refers to a coat of arms. Let&#39;s now load this data into fastai . learn = cnn_learner(dls_classification, resnet18, metrics=[accuracy, F1Score()]) . Often if we pass fastai a dataloader it will be able to infer the correct loss function based on this data. we can access this using the loss_func attribute. . learn.loss_func . FlattenedLoss of CrossEntropyLoss() . As promised this is a variant on the CrossEntropyLoss we saw earlier. Let&#39;s now fit it for a bit. . learn.fit(5) . epoch train_loss valid_loss accuracy f1_score time . 0 | 1.023169 | 0.786303 | 0.785714 | 0.769231 | 00:03 | . 1 | 0.721281 | 0.576258 | 0.821429 | 0.814815 | 00:03 | . 2 | 0.477446 | 0.339626 | 0.821429 | 0.782609 | 00:04 | . 3 | 0.423173 | 0.331097 | 0.821429 | 0.782609 | 00:03 | . 4 | 0.351390 | 0.239433 | 0.857143 | 0.818182 | 00:03 | . Now we have a model, we&#39;ll grab the predictions . acts, _ = learn.get_preds() acts . tensor([[9.9795e-01, 2.0519e-03], [9.9811e-01, 1.8889e-03], [9.9911e-01, 8.8577e-04], [9.9680e-01, 3.2038e-03], [6.5879e-01, 3.4121e-01], [1.2512e-04, 9.9987e-01], [9.9734e-01, 2.6599e-03], [9.8866e-01, 1.1341e-02], [9.2739e-01, 7.2608e-02], [9.8336e-01, 1.6643e-02], [1.7059e-01, 8.2941e-01], [9.9899e-01, 1.0067e-03], [5.2081e-01, 4.7919e-01], [4.9184e-03, 9.9508e-01], [9.9930e-01, 7.0161e-04], [1.0109e-04, 9.9990e-01], [9.9533e-01, 4.6670e-03], [3.6834e-02, 9.6317e-01], [5.7022e-06, 9.9999e-01], [9.8635e-01, 1.3647e-02], [2.1610e-01, 7.8390e-01], [2.3512e-02, 9.7649e-01], [2.9994e-01, 7.0006e-01], [4.2728e-02, 9.5727e-01], [9.8494e-01, 1.5062e-02], [1.4194e-01, 8.5806e-01], [6.8620e-01, 3.1380e-01], [7.3493e-01, 2.6507e-01]]) . These are the predictions for each class, let&#39;s confirm these all sum to 1. . acts.sum(dim=1) . tensor([1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000, 1.0000]) . If we look at the max for each probability we&#39;ll see they tend to be high. . acts.max(dim=1)[0] . tensor([0.9979, 0.9981, 0.9991, 0.9968, 0.6588, 0.9999, 0.9973, 0.9887, 0.9274, 0.9834, 0.8294, 0.9990, 0.5208, 0.9951, 0.9993, 0.9999, 0.9953, 0.9632, 1.0000, 0.9864, 0.7839, 0.9765, 0.7001, 0.9573, 0.9849, 0.8581, 0.6862, 0.7349]) . Looking at the mean, max and min: . acts.max(dim=1)[0].mean(), acts.max(dim=1)[0].max(), acts.max(dim=1)[0].min(), . (tensor(0.9113), tensor(1.0000), tensor(0.5208)) . This is desirable if the input we are trying to label does neatly fit the categories but if we are trying to label something which is more ambiguous then this might be less useful. A particular case where this certainty might not be so helpful is when your model may possibly face out of domain images, i.e. see things it hasn&#39;t seen before and for which none of the classes it is trying to predict should apply. Let&#39;s load a new dataset of images of people. . people = get_image_files(&#39;data/cv_workshop_exercise_data/&#39;, folders=&#39;people&#39;) people . (#38) [Path(&#39;data/cv_workshop_exercise_data/people/000001929_03_000249_2_De Aardbol Magazijn van hedendaagsche land en volkenkunde Met platen en kaarten [Deel 4 9 by P H W ]_1839.jpg&#39;),Path(&#39;data/cv_workshop_exercise_data/people/000194796_0_000133_1_Historical Collections relating to the history and antiquities of every town in Massachusetts with geographical descriptions [With illustrations ]_1839.jpg&#39;),Path(&#39;data/cv_workshop_exercise_data/people/000194796_0_000140_1_Historical Collections relating to the history and antiquities of every town in Massachusetts with geographical descriptions [With illustrations ]_1839.jpg&#39;),Path(&#39;data/cv_workshop_exercise_data/people/000001929_03_000058_1_De Aardbol Magazijn van hedendaagsche land en volkenkunde Met platen en kaarten [Deel 4 9 by P H W ]_1839.jpg&#39;),Path(&#39;data/cv_workshop_exercise_data/people/001099118_02_000168_1_The Victories of the British Armies with anecdotes illustrative of modern warfare By the author of Stories of Waterloo [i e William Hamilton Maxwell] etc [With plates ]_1839.jpg&#39;),Path(&#39;data/cv_workshop_exercise_data/people/000001929_08_000107_1_De Aardbol Magazijn van hedendaagsche land en volkenkunde Met platen en kaarten [Deel 4 9 by P H W ]_1839.jpg&#39;),Path(&#39;data/cv_workshop_exercise_data/people/000001929_06_000006_1_De Aardbol Magazijn van hedendaagsche land en volkenkunde Met platen en kaarten [Deel 4 9 by P H W ]_1839.jpg&#39;),Path(&#39;data/cv_workshop_exercise_data/people/000979699_0_000368_1_Indian Captivities being a collection of the most remarkable narratives of persons taken captive by the North American Indians To which are added notes historical biographical etc_1839.jpg&#39;),Path(&#39;data/cv_workshop_exercise_data/people/000001929_06_000007_1_De Aardbol Magazijn van hedendaagsche land en volkenkunde Met platen en kaarten [Deel 4 9 by P H W ]_1839.jpg&#39;),Path(&#39;data/cv_workshop_exercise_data/people/000001929_08_000106_1_De Aardbol Magazijn van hedendaagsche land en volkenkunde Met platen en kaarten [Deel 4 9 by P H W ]_1839.jpg&#39;)...] . PILImage.create(people[5]) . What happens if we predict one of these: . learn.predict(PILImage.create(people[5])) . (&#39;building&#39;, tensor(0), tensor([0.9916, 0.0084])) . It&#39;s predict that Torstenson is a building with a probability of 99% certainty! Let&#39;s look at some more . preds, _ = learn.get_preds(dl=learn.dls.test_dl(people)) . now we have a bunch of predictions let&#39;s get the max value. i.e. the probability for the label it predicted and see what the min, max and median is: . preds.max(dim=1)[0].min(), preds.max(dim=1)[0].max(), preds.max(dim=1)[0].median() . (tensor(0.5288), tensor(1.0000), tensor(0.9765)) . Although the min is fairly low, the median value is pretty confidently predicting a wrong label. Let&#39;s see how this differs if we instead use a &#39;label model&#39;. fastai expects labels to be inside a list, we can create a new column which puts our classes inside a list. . df[&#39;label&#39;] = df[&#39;class_label&#39;].apply(lambda x: [x]) . We&#39;ll now load in the data. The only difference here is that we specify a y_block, this forces fastai to choose the correct loss function. . dls_label = ImageDataLoaders.from_df(df,fn_col=&#39;fname&#39;, valid_pct=0.4, label_col=&#39;label&#39;, y_block=MultiCategoryBlock, item_tfms=Resize(128, ResizeMethod.Squish), bs=8, num_workers=0) dls_label.show_batch() . If we now create the learner, we&#39;ll see a different loss function . label_learn = cnn_learner(dls_label, resnet18, metrics=[F1ScoreMulti()]) label_learn.loss_func . FlattenedLoss of BCEWithLogitsLoss() . Again we&#39;ll fit for a while . label_learn.fit(5) . epoch train_loss valid_loss f1_score time . 0 | 0.979886 | 1.107939 | 0.520422 | 00:03 | . 1 | 0.742499 | 0.530855 | 0.749681 | 00:03 | . 2 | 0.540384 | 0.294314 | 0.858553 | 00:03 | . 3 | 0.428714 | 0.197953 | 0.874603 | 00:03 | . 4 | 0.358649 | 0.157847 | 0.973684 | 00:03 | . Now we&#39;ll grab some predictions again . preds, _ = label_learn.get_preds() preds . tensor([[9.8592e-01, 2.2629e-02], [5.0721e-01, 1.0558e-01], [9.9954e-01, 1.4539e-02], [2.6342e-01, 9.7471e-01], [9.9732e-01, 3.8691e-04], [1.0064e-02, 9.9507e-01], [1.5311e-02, 9.7020e-01], [2.2675e-03, 9.9944e-01], [9.7902e-01, 2.7719e-02], [6.0582e-01, 1.2015e-01], [7.7181e-02, 9.9448e-01], [9.8096e-01, 5.7364e-03], [8.2864e-01, 4.2955e-01], [9.0980e-01, 1.1982e-02], [9.6249e-01, 1.3159e-02], [2.3728e-01, 6.0858e-01], [9.9327e-01, 4.9904e-03], [9.1160e-04, 9.8218e-01], [9.7016e-01, 2.2057e-03], [9.8055e-01, 1.9247e-02], [8.3900e-01, 2.7438e-01], [4.3518e-01, 1.6118e-01], [6.8165e-01, 1.7120e-01], [7.7239e-01, 5.4064e-02], [9.9350e-01, 7.2269e-02], [6.3511e-01, 1.7830e-02], [1.3994e-01, 8.5564e-01], [2.6746e-02, 6.9240e-01]]) . Let&#39;s see what these add up to . preds.sum(dim=1) . tensor([1.0085, 0.6128, 1.0141, 1.2381, 0.9977, 1.0051, 0.9855, 1.0017, 1.0067, 0.7260, 1.0717, 0.9867, 1.2582, 0.9218, 0.9756, 0.8459, 0.9983, 0.9831, 0.9724, 0.9998, 1.1134, 0.5964, 0.8528, 0.8265, 1.0658, 0.6529, 0.9956, 0.7191]) . Not 1! Again this is because our labels are now independent of each other. We can see that if we now grab the max for each possible lab and take the min, max and median we get quite different results . preds.max(dim=1)[0].min(), preds.max(dim=1)[0].max(), preds.max(dim=1)[0].median() . (tensor(0.4352), tensor(0.9995), tensor(0.9702)) . Since the labels are now independent these probabilities have a much wider range. The lowest value is lower than would be possible when we use a classification model with two classes. This might be useful when we are trying to capture labels which are not tightly defined and therefore we might want our model to have more &#39;flexibility&#39; in the predictions it makes. Let&#39;s see what happens if we predict the same image of Torstenson we had earlier . label_learn.predict(PILImage.create(people[5])) . ((#1) [&#39;building&#39;], tensor([ True, False]), tensor([0.9992, 0.0055])) . Oh dear, this seems to have the same problem as before. However, we have the option to set a threshold for predictions. If we set a threshold and train again... . label_learn = cnn_learner(dls_label, resnet18, metrics=[F1ScoreMulti()],loss_func=BCEWithLogitsLossFlat(thresh=0.9)) . label_learn.fit(5) . epoch train_loss valid_loss f1_score time . 0 | 0.746691 | 0.450183 | 0.655556 | 00:03 | . 1 | 0.572374 | 0.352565 | 0.843939 | 00:03 | . 2 | 0.477375 | 0.328633 | 0.856250 | 00:03 | . 3 | 0.359104 | 0.320807 | 0.841642 | 00:03 | . 4 | 0.306263 | 0.327382 | 0.860795 | 00:03 | . If we now predict the same image . label_learn.predict(PILImage.create(people[5])) . ((#0) [], tensor([False, False]), tensor([0.8369, 0.4833])) . This time we don&#39;t get a prediction! The flexibility of being able to set a threshold is a very nice feature of using this type of loss function since it gives you some more options for deciding how confident you want a model to be. . Discussion . The aim of this blog post was to explore some of the implications of doing &#39;classification&#39; vs &#39;labeling&#39;. Although label models are often only considered in relation to models with multiple labels, they can also be applied to models with only one possible label per image. The key distinction between these two approaches is the loss functions. There are implications of choosing between these two loss functions. . Because of the Softmax component, a classification model will always have probabilities for each class which add to one. Beyond this thought the use of the exponent tends to push one class probability higher than the others. . In contrast the loss function for a labeling model pushes each individual labels probability between 0 and 1, but it doesn&#39;t require all of label probabilities to add to 1. . Labeling in a Digital Humanities/GLAM context . When you have clear labels which are distinct from each other, it is useful to have one label be &#39;pushed to the top&#39;. Often in a humanities or GLAM context labels may not be as clear cut. . This might be because the concepts which you are trying to capture in the labels have fuzzy borders, or because the source material contains some complexities. For example, working with ORC&#39;d text of varying quality. In these situations the fact that softmax will be likely to lead to one prediction being much stronger may not be desirable. . Although you can work with the raw probabilities predicted by the model to capture some potential ambiguity, because one class will tend to be pushed higher (because of the exponent in softmax) this doesn&#39;t fully address this issue. . A preference for one or another approach, will depend on the task at hand but even when you only have one single possible label per input, it might still be helpful to consider using a labeling model i.e. BCELoss instead of a classification model using CrossEntropyLoss. . There are of course other solutions to changing out the loss function you used to train the model. I&#39;m hoping to explore some of these soon 🤓 .",
            "url": "https://danielvanstrien.xyz/models/labels/loss%20functions/2020/10/12/labelling_vs_classification_models.html",
            "relUrl": "/models/labels/loss%20functions/2020/10/12/labelling_vs_classification_models.html",
            "date": " • Oct 12, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Virtual memory",
            "content": "Conda . Package installation . Use Mambda instead of conda to install packages. We&#39;ve done what we do at @QuantStack: making things run faster. Conda has been getting slower with @condaforge&#39;s growing package registry -- we&#39;re fighting it with raw C++ power in the #mamba package!Try now:conda install mamba -c conda-forge/label/mamba-alpha -c conda-forge pic.twitter.com/tnlVQKAbv4 . &mdash; Wolf Vollprecht (@wuoulf) March 25, 2019 . Pandas . import pandas as pd . Drop rows if frequency of a class id below n . sometimes it can be useful to drop rows in a dataset which appear to few times, in the most extreme cases datasets might have only one observation for a particular class. . rows = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;2&#39;,&#39;1&#39;]; df = pd.DataFrame({&#39;a&#39;:rows, &#39;b&#39;: rows}) . df . a b . 0 1 | 1 | . 1 2 | 2 | . 2 3 | 3 | . 3 2 | 2 | . 4 1 | 1 | . df[df.groupby(&#39;a&#39;)[&#39;a&#39;].transform(&#39;count&#39;).ge(2)] . a b . 0 1 | 1 | . 1 2 | 2 | . 3 2 | 2 | . 4 1 | 1 | . fastai . Some things related to fastai (version 2) . Inference . Sources of information: . https://forums.fast.ai/t/doing-predictions-and-showing-results-with-v2-questions-best-practice-thread/62915/6 | . from fastai.vision.all import * . Train a learner so we can do some inference . path = untar_data(URLs.PETS) files = get_image_files(path/&quot;images&quot;) def label_func(f): return f[0].isupper() dls = ImageDataLoaders.from_name_func(path, files, label_func, item_tfms=Resize(32), num_workers=0) . dls.show_batch() . learn = cnn_learner(dls, resnet18, metrics=error_rate) learn.fine_tune(1) . epoch train_loss valid_loss error_rate time . 0 | 0.999297 | 0.718680 | 0.324763 | 01:26 | . epoch train_loss valid_loss error_rate time . 0 | 0.722174 | 0.548298 | 0.272666 | 01:41 | . Making predictions . preds = learn.get_preds() . Decoding predictions . To decode the output from get_preds. Can decode a label using the dls. Accessing the categorize.decode attribute to get a human readable value. . dls.categorize.decode(0) . &#39;False&#39; . If we have the predictions tensors i.e. the predictions for each class: . preds[0][0] . tensor([0.2110, 0.7890]) . numpy argmax can be used to get the index of the most likely predictions` . dls.categorize.decode(np.argmax(preds[0][0])) . &#39;True&#39; . Can also access the confidence for the maximum prediction directly; . max(preds[0][0]) . tensor(0.7890) . Test time augmentation . dls = ImageDataLoaders.from_name_func(path, files, label_func, item_tfms=Resize(32), batch_tfms=[*aug_transforms()],num_workers=0) learn = cnn_learner(dls, resnet18, metrics=error_rate) learn.fit(1) . epoch train_loss valid_loss error_rate time . 0 | 0.898633 | 0.700572 | 0.299729 | 01:11 | . doc(learn.tta) . Learner.tta[source] . Learner.tta(ds_idx=1, dl=None, n=4, item_tfms=None, batch_tfms=None, beta=0.25, use_max=False) . Return predictions on the ds_idx dataset or dl using Test Time Augmentation . Show in docs . preds, targs = learn.tta() . . error_rate(preds, targs).item() . 0.28890395164489746 . Dataloaders . Accessing input data . Accessing the input from the data loaders can be done through items. The L here is just to automagically limit the number of items displayed in the notebook . L(dls.items) . (#5912) [Path(&#39;/Users/dvanstrien/.fastai/data/oxford-iiit-pet/images/Bengal_76.jpg&#39;),Path(&#39;/Users/dvanstrien/.fastai/data/oxford-iiit-pet/images/shiba_inu_8.jpg&#39;),Path(&#39;/Users/dvanstrien/.fastai/data/oxford-iiit-pet/images/newfoundland_87.jpg&#39;),Path(&#39;/Users/dvanstrien/.fastai/data/oxford-iiit-pet/images/english_cocker_spaniel_11.jpg&#39;),Path(&#39;/Users/dvanstrien/.fastai/data/oxford-iiit-pet/images/pug_50.jpg&#39;),Path(&#39;/Users/dvanstrien/.fastai/data/oxford-iiit-pet/images/chihuahua_58.jpg&#39;),Path(&#39;/Users/dvanstrien/.fastai/data/oxford-iiit-pet/images/British_Shorthair_74.jpg&#39;),Path(&#39;/Users/dvanstrien/.fastai/data/oxford-iiit-pet/images/pomeranian_75.jpg&#39;),Path(&#39;/Users/dvanstrien/.fastai/data/oxford-iiit-pet/images/Russian_Blue_104.jpg&#39;),Path(&#39;/Users/dvanstrien/.fastai/data/oxford-iiit-pet/images/Bengal_77.jpg&#39;)...] . Indexing dataloader items . Items can be indexed in the usual way which can be useful to get back to orginal input based on an index . dls.items[0] . Path(&#39;/Users/dvanstrien/.fastai/data/oxford-iiit-pet/images/german_shorthaired_54.jpg&#39;) . Git . Filtering repositories . If you end up with a big repository which you want to split off into a new repo but maintain the history for the stuff in that folder. Use https://github.com/newren/git-filter-repo/ to filter the repo itself. To do this I pulled the old repo into a new folder to make sure I didn&#39;t destroy anything by mistake. You filter out a repo based on a folder and other potential filters. Once this repo has been filtered you can push it to a new repo. .",
            "url": "https://danielvanstrien.xyz/fastai/conda/pandas/2020/08/29/code_snippets.html",
            "relUrl": "/fastai/conda/pandas/2020/08/29/code_snippets.html",
            "date": " • Aug 29, 2020"
        }
        
    
  
    
        ,"post10": {
            "title": "Hyperparameter Optimization for Transfer Learning",
            "content": "tl;dr . This post covers: . the motivations for &#39;pragmatic hyperparameters optimization&#39; | how to do this using Optuna (with an example applied to the fastai2 library) | . Optimizing hyperparameters? . Deep learning models have a range of Hyperparameters. These include the basic building blocks of a model like the number of layers used or the size of embedding layers, and the parameters for the training of models such as learning rate. Changing some of these parameters will improve the performance of a model. There is therefore a potential win from finding the right values for these parameters. . Auto ML vs pragmatic hyperparameters optimization . As a way of framing &#39;pragmatic search&#39;, it is useful to contrast it to Auto ML. If you haven&#39;t come across it before: . The term AutoML has traditionally been used to describe automated methods for model selection and/or hyperparameter optimization. - 1. . In particular what is termed Auto ML often includes a search across model and Hyperparameters but can also refer to &#39;Neural Architecture Search&#39; in which the objective is to piece together a new model type for a specific problem or dataset. An underlying assumption of some of this Auto ML approach is that each problem or dataset requires a unique model architecture. . In contrast a more &#39;pragmatic&#39; approach uses an existing model architectures which have been shown to work across a range of datasets and tasks, and utilise transfer learning and other &#39;tricks&#39; like cyclical learning rates and data augmentation. In a heritage context, it is likely that there are going to be bigger issues with imbalanced classes, noisy labels etc, and focusing on designing a custom architecture is probably going to lead to modest improvements in the performance of the model. . So what remains to be optimized? . In contrast to Auto ML which can involve looking at huge range of potential architectures and parameters we could instead limit our focus to smaller set of things which may have a large impact on the performance of your model. . As an example use case for hyperparameters optimization I&#39;ll use two datasets which contain transcripts of trials from the Old Bailey online and which are classified into various categories (theft, deception, etc). One of the datasets is drawn the decade 1830 the other one 1730. The approach taken to classifying these trials will be to follow the &quot;Universal Language Model Fine-tuning for Text Classification&quot; approach. 2. . I won&#39;t give an in depth summary of the approach here but idea is that: . A language model - in this case a LSTM based model - is trained on a Wikipedia text. This provides a &quot;general&quot; language model that learns to &quot;understand&quot; general features of a language, in this case English | this language model is then fine-tuned on a target dataset, in the orginal paper this is IMDB movie reviews. | one this language model has been fine-tuned on the target dataset this fine-tuned language model is used as input for a classifier | . The intuition here is that by utilising a pre-trained language model the Wikipedia part, and the fine-tuning part we get the benefits of a massive training set (Wikipedia) whilst also being able to &#39;focus&#39; the language model on a target corpus which will use language differently. This makes a lot of intuitive sense, but a question in this use case is how much to fine-tune the language model on our target datasets. A reasonable assumption might be that since language will be more different in 1730 compared to 1830 we may want to fine tune the language model trained on Wikipedia more on the 1730 dataset. . We could of course test through some trial and error experiments, but this is a question which may benefit from some more systematic searching for appropriate hyperparameters. Before we get into this example in more depth I&#39;ll discuss the library I&#39;m working with for doing this hyperparameter searching. . Optuna: A hyperparameter optimization framework . In this post I will be using Optuna &quot;an automatic hyperparameter optimization software framework, particularly designed for machine learning&quot;. 3. . There are some really nice features in Optuna which I&#39;ll cover in this post as I explore the question of language model fine-tuning, so hopefully even if you don&#39;t care about the specific use case it might still provide a useful overview of Optuna. . In this blog post my examples will use version two of the fastai library but there really isn&#39;t anything that won&#39;t translate to other frameworks. Optuna has integrations for a number of libraries (including version 1 of fastai) but for this blog I won&#39;t use this integration. . A simple optimization example . To show the approach used in Optuna I&#39;ll use a simple image classification example. In this case using a toy example of classifying people vs cats in images taken from 19th Century books. . Optuna has two main concepts to understand: study and trial. A study is the overarching process of optimization based on some objective function. A trial is a single test/execution of the objective function. We&#39;ll return to this in more detail. For now lets look at a simple example. . For our first example we&#39;ll just use Optuna to test whether to use a pre-trained model or not. If the option is True then the ResNet18 model we use will use weights from pre-training on ImageNet, if False the model will start with random weights. . Looking at the high level steps of using Optuna (I&#39;ll go into more detail later). We create an objective function: . !wget -q https://zenodo.org/record/3689444/files/humancats.zip?download=1 !unzip -q *humancats.zip* -d data/ . . def objective(trial): is_pretrained = trial.suggest_categorical(&#39;pre_trained&#39;, [True, False]) dls = ImageDataLoaders.from_folder(&#39;data/human_vs_cats/&#39;, valid_pct=0.4, item_tfms=Resize(64)) learn = cnn_learner(dls, resnet18, pretrained=is_pretrained, metrics=[accuracy]) learn.fit(1) acc = learn.recorder.values[-1][-1] return acc . Most of this will look familiar if you are have used fastai before. Once we have this we create a study: . study = optuna.create_study(direction=&#39;maximize&#39;) . and then optimize this study: . study.optimize(objective, n_trials=2) . epoch train_loss valid_loss accuracy time . 0 | 1.503035 | 0.710954 | 0.555556 | 00:06 | . [I 2020-06-04 16:58:49,862] Finished trial#0 with value: 0.5555555820465088 with parameters: {&#39;pre_trained&#39;: False}. Best is trial#0 with value: 0.5555555820465088. . epoch train_loss valid_loss accuracy time . 0 | 1.691165 | 1.218440 | 0.555556 | 00:05 | . [I 2020-06-04 16:58:56,272] Finished trial#1 with value: 0.5555555820465088 with parameters: {&#39;pre_trained&#39;: False}. Best is trial#0 with value: 0.5555555820465088. . Once we&#39;ve run some trials we can inspect the study object for the best value we&#39;re optimizing for. In this case this is the accuracy but it will be whatever is returned by our function. We can also see the parameters which led to this value. . study.best_value, study.best_params . (0.5555555820465088, {&#39;pre_trained&#39;: False}) . This toy example wasn&#39;t particularly useful (it just confirmed we probably want to use a pre-trained model) but going through the steps provides an overview of the main things required by Optuna. Starting with defining a function objective . def objective(trial): . this is the function we want to optimize. We could call it something else but following the convention in the Optuna docs the function we&#39;ll call it objective. This function takes &#39;trial&#39; as an argument. . is_pretrained = trial.suggest_categorical(&#39;pre_trained&#39;, [True, False]) . here we use trial to &quot;suggest&quot; a categorical in this case one of two options (whether pre trained is set to true or false). We do this using trial.suggest_categorical and pass it the potential options (in this case True or False). . trial.suggest_blah defines the paramater &quot;search space&quot; for Optuna. We&#39;ll look at all of the options for this later on. The final step in defining our objective function i.e. the thing we want to optimize: . return acc . This return value is objective value that Optuna will optimize. Because this is just the return value of a function there is a lot of flexibility in what this can be. In this example it is accuracy but it could be training or validation loss, or another training metrics. Later on we&#39;ll look at this in more detail. . Now let&#39;s look at the study part: . study = optuna.create_study(direction=&#39;maximize&#39;) . This is the most simple way of creating a study. This creates a study object, again, we&#39;ll look at more options as we go along. The one option we pass here is the direction. This refers to to whether Optuna should try to increase the return value of our optimization function or decrease it. This depends on what you a tracking i.e. you&#39;d want to minimize error or validation loss but increase accuracy or F1 score. . Looking at the overview provided in the Optuna docs we have three main building blocks: . Trial: A single call of the objective function . | Study: An optimization session, which is a set of trials . | Parameter: A variable whose value is to be optimized . | . Parameter search space . Borrowing once more from the docs: . The difficulty of optimization increases roughly exponentially with regard to the number of parameters. That is, the number of necessary trials increases exponentially when you increase the number of parameters, so it is recommended to not add unimportant parameters . This is a crucial point. Particularly if we want to use optimization in a pragmatic way. When we have existing knowledge or evidence about what works well for a particular problem, we should use that rather than asking Optuna to find this out for us. There are some extra tricks to make our search for the best parameters more efficient which will be explored below but for now let&#39;s get back to the example use case. . Fine-tuning a language model . df_1830 = pd.read_csv(&#39;https://gist.githubusercontent.com/davanstrien/4bc85d8a4127a2791732280ffaa43293/raw/cd1a3cc53674b64c8f130edbcb34e835afa665fb/1830trial.csv&#39;) df_1730 = pd.read_csv(&#39;https://gist.githubusercontent.com/davanstrien/4bc85d8a4127a2791732280ffaa43293/raw/cd1a3cc53674b64c8f130edbcb34e835afa665fb/1730trial.csv&#39;) . . For the sake of brevity I won&#39;t cover the steps to generate this dataset the instructions for doing so for the 1830s trials can be found here (and can be easily adapted for the 1730s trial). . Unnamed: 0 Unnamed: 0.1 0 file broad narrow text . 0 14463.0 | t18361128-57a | theft-housebreaking | t18361128-57a.txt | theft | housebreaking | n n n n n57. n n n n nJOHN BYE n the younger and n n n n nFREDERICK BYE n were indicted for n n feloniously breaking and entering the dwelling-house of n n n nJohn Bye, on the n21st of November, at nSt. Giles-in-the-Fields, and stealing therein 12 apples, value 9d.; 1 box, value 1d.; 24 pence, and 1 twopenny-piece; the goods and monies of n n n nMary Byrne. n n n n n n nMARY BYRNE n. I sell fruit; I live in Titchbourne-court, Holborn. On the 21st of November I went out at one o&#39;clock, and locked my door?I left 2s. worth of penny-pieces in my drawer, and two dozen large apples?I came... | . 1 19021.0 | t18380917-2214 | theft-pocketpicking | t18380917-2214.txt | theft | pocketpicking | n n n n2214. n n n n nMARY SMITH n was indicted n n for stealing, on the n16th of September, 1 purse, value 2d.; 3 half-crowns, and twopence; the goods and monies of n n n nGeorge Sainsbury, from his person. n n n n n n nGEORGE SAINSBURY n. Between twelve and one o&#39;clock, on the 16th of September, I went to sleep in the fields, at Barnsbury-park, Islington, I had three half-crowns, and twopence, in my pocket?I was awoke, and missed my money?I went to the prisoner, and charged her with it?she said she had not got it?I followed her, and saw her drop ray purse down, it had two penny piece... | . We load the data using fastai2 TextDataLoaders . def load_lm_data(df): data_lm = TextDataLoaders.from_df( df.sample(frac=0.5), text_col=&quot;text&quot;, is_lm=True, bs=128 ) return data_lm # Classification data def load_class_data(df, data_lm): data_class = TextDataLoaders.from_df( df.sample(frac=0.5), text_col=&quot;text&quot;, label_col=&quot;broad&quot;, valid_pct=0.3, bs=128, text_vocab=data_lm.vocab, ) return data_class . . data_lm = load_lm_data(df_1830) data_class = load_class_data(df_1830, data_lm) . Create the language model learner and classifier learner: . def create_lm(): return language_model_learner(data_lm, AWD_LSTM, pretrained=True).to_fp16() def create_class_learn(): return text_classifier_learner( data_class, AWD_LSTM, metrics=[accuracy, F1Score(average=&quot;weighted&quot;)] ).to_fp16() . . Optuna trial suggest . In the example above trial.suggest_categorical was used to define the potential parameter. Optuna has five kinds of parameters which can be optimized. These all work through the trial.suggest method. . Categorical . This can be used for models, optimizers, and for True/False flags. . optimizer = trial.suggest_categorical(&#39;optimizer&#39;, [&#39;MomentumSGD&#39;, &#39;Adam&#39;]) . Integer . n_epochs = trial.suggest_int(&#39;num_epochs&#39;, 1, 3) . Uniform . max_zoom = trial.suggest_uniform(&#39;max_zoom&#39;, 0.0, 1.0) . Loguniform . learning_rate = trial.suggest_loguniform(&#39;learning_rate&#39;, 1e-4, 1e-2) . Discrete-uniform . drop_path_rate = trial.suggest_discrete_uniform(&#39;drop_path_rate&#39;, 0.0, 1.0) . The string value provides a key for the parameters which is used to access these parameters later, it&#39;s therefore important to give them a sensible name. . Limiting parameters? . Adding additional trial.suggest to your optimization function increases the search space for Optuna to optimize over so you should avoid adding additional parameters if they are not necessary. . The other way in which the search space can be constrained is to limit the range of the search i.e. for learning rate . learning_rate = trial.suggest_loguniform(&#39;learning_rate&#39;, 1e-4, 1e-2) . is preferable over . learning_rate = trial.suggest_loguniform(&#39;learning_rate&#39;, 1e-10, 1e-1) . if it&#39;s not likely the optimal learning rate will sit outside of this range. . How many parameters you include will also depend on the type of model you are trying to train. In the use case of fine-tuning a language model we will want to limit the options more since language models are generally quite slow to train. If, on the other hand, we were trying to improve an image classification model which only takes minutes to train then searching through a larger parameter space would become more feasible. . Objective function for fine-tuning a language model . The objective function below has two stages; train a language model, use the encoder from this language model for a classifier. . The parameters we&#39;re trying to optimize in this case are: . learning rate for the frozen language model | number of epochs to train only the final layers of the language model | learning rate for the unfrozen language model | number of epochs for training the whole language model | . We use lm_learn.no_bar() as a context manager to reduce the amount of logging. . def objective(trial): lm_learn = create_lm() lr_frozen = trial.suggest_loguniform(&quot;learning_rate_frozen&quot;, 1e-4, 1e-1) head_epochs = trial.suggest_int(&quot;head_epochs&quot;, 1, 5) with lm_learn.no_bar(): lm_learn.fit_one_cycle(head_epochs, lr_max=lr_frozen) # Unfrozen Language model lr_unfreeze = trial.suggest_loguniform(&quot;learning_rate_unfrozen&quot;, 1e-7, 1e-1) body_epochs = trial.suggest_int(&quot;lm_body_epochs&quot;, 1, 5) lm_learn.unfreeze() with lm_learn.no_bar(): lm_learn.fit_one_cycle(body_epochs, lr_unfreeze) lm_learn.save_encoder(&quot;finetuned&quot;) # Classification cl_learn = create_class_learn() cl_learn.load_encoder(&quot;finetuned&quot;) cl_learn.fit_one_cycle(3) f1 = cl_learn.recorder.values[-1][-1] return f1 . We can give our study a name and also store it in a database. This allows for resuming previous trials later and accessing the history of previous trials. There are various options for database backends outlined in the documentation. . Creating the study . study_name = &quot;tunelm1830&quot; study = optuna.create_study( study_name=study_name, direction=&quot;maximize&quot;, storage=f&quot;sqlite:///{out_path}/optuma/example.db&quot;, ) . [I 2020-06-05 15:09:05,470] A new study created with name: tunelm1830 . Optimize . Now we&#39;ll run 3 trials and use show_progress_bar=True to give an ETA on when the trials will finish. . study.optimize(objective, n_trials=3, show_progress_bar=True) . /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:61: ExperimentalWarning: Progress bar is experimental (supported from v1.2.0). The interface can change in the future. . (#4) [0,5.382655620574951,4.875850200653076,&#39;00:24&#39;] (#4) [1,5.292355537414551,4.737764835357666,&#39;00:24&#39;] (#4) [2,5.183778285980225,4.647550106048584,&#39;00:24&#39;] (#4) [3,5.11093282699585,4.608272552490234,&#39;00:24&#39;] (#4) [4,5.072442054748535,4.601930618286133,&#39;00:24&#39;] (#4) [0,4.7495622634887695,4.241390228271484,&#39;00:27&#39;] . epoch train_loss valid_loss accuracy f1_score time . 0 | 2.326032 | 2.070412 | 0.020000 | 0.017034 | 00:10 | . 1 | 2.302230 | 2.136864 | 0.023333 | 0.003590 | 00:10 | . 2 | 2.269061 | 2.180663 | 0.016667 | 0.004408 | 00:10 | . [I 2020-06-05 15:12:20,128] Finished trial#0 with value: 0.00440805109922757 with parameters: {&#39;learning_rate_frozen&#39;: 0.00014124685078723662, &#39;head_epochs&#39;: 5, &#39;learning_rate_unfrozen&#39;: 0.00010276862511970148, &#39;lm_body_epochs&#39;: 1}. Best is trial#0 with value: 0.00440805109922757. (#4) [0,4.713407516479492,3.7350399494171143,&#39;00:24&#39;] (#4) [1,3.998744249343872,3.3055806159973145,&#39;00:24&#39;] (#4) [2,3.6486754417419434,3.192685842514038,&#39;00:24&#39;] (#4) [3,3.4996860027313232,3.1756556034088135,&#39;00:24&#39;] (#4) [0,3.4227023124694824,3.163315534591675,&#39;00:27&#39;] (#4) [1,3.3954737186431885,3.140226364135742,&#39;00:27&#39;] (#4) [2,3.3778774738311768,3.125929117202759,&#39;00:27&#39;] (#4) [3,3.357388973236084,3.119621753692627,&#39;00:27&#39;] (#4) [4,3.3542206287384033,3.1186859607696533,&#39;00:27&#39;] . epoch train_loss valid_loss accuracy f1_score time . 0 | 2.368984 | 2.121307 | 0.013333 | 0.000759 | 00:11 | . 1 | 2.335033 | 2.022853 | 0.250000 | 0.368652 | 00:10 | . 2 | 2.296630 | 1.948786 | 0.313333 | 0.452365 | 00:10 | . [I 2020-06-05 15:16:49,562] Finished trial#1 with value: 0.45236502121696065 with parameters: {&#39;learning_rate_frozen&#39;: 0.0060643425219262335, &#39;head_epochs&#39;: 4, &#39;learning_rate_unfrozen&#39;: 2.734844423029637e-05, &#39;lm_body_epochs&#39;: 5}. Best is trial#1 with value: 0.45236502121696065. (#4) [0,5.3748459815979,4.851675987243652,&#39;00:24&#39;] (#4) [1,5.247058868408203,4.672318935394287,&#39;00:24&#39;] (#4) [2,5.111597061157227,4.559732437133789,&#39;00:24&#39;] (#4) [3,5.026832103729248,4.512131690979004,&#39;00:24&#39;] (#4) [4,4.982809066772461,4.5044732093811035,&#39;00:24&#39;] (#4) [0,4.915407657623291,4.423311233520508,&#39;00:27&#39;] (#4) [1,4.857243061065674,4.394893646240234,&#39;00:27&#39;] . epoch train_loss valid_loss accuracy f1_score time . 0 | 2.368439 | 2.036706 | 0.240000 | 0.360355 | 00:10 | . 1 | 2.359790 | 2.093103 | 0.033333 | 0.045878 | 00:09 | . 2 | 2.331945 | 2.140194 | 0.016667 | 0.013589 | 00:10 | . [I 2020-06-05 15:20:20,119] Finished trial#2 with value: 0.013588651008106425 with parameters: {&#39;learning_rate_frozen&#39;: 0.0001971120155925954, &#39;head_epochs&#39;: 5, &#39;learning_rate_unfrozen&#39;: 1.0649951798153689e-05, &#39;lm_body_epochs&#39;: 2}. Best is trial#1 with value: 0.45236502121696065. . Results . You can see how trials are peforming in the logs with the last part of the log reporting the best trial so far. We can now access the best value and best_params. . study.best_value, study.best_params . (0.45236502121696065, {&#39;head_epochs&#39;: 4, &#39;learning_rate_frozen&#39;: 0.0060643425219262335, &#39;learning_rate_unfrozen&#39;: 2.734844423029637e-05, &#39;lm_body_epochs&#39;: 5}) . Where to start the search? . As I mentioned at the start I think it&#39;s worth trying to think pragmatically about how to use hyper-parameter optimizations. I already mentioned limiting the number of parameters and limiting the potential options in these parameters. However we can also intervene more directly in how Optuna runs a trial. . Suggesting a learning rate . One of the yummiest features in fastai which has also made it into other deep-learning libraries is the learning rate finer lr_find(). As a reminder: . the LR Finder trains the model with exp onentially growing learning rates from start_lr to end_lr for num_it and stops in case of divergence (unless stop_div=False) then plots the losses vs the learning rates with a log scale. . Since the Learning rate finder often gives a good learning rate we should see if we can use this as a starting point for our trials. . Enqueue trial . Using enqueue_trial you can queue up trials with specied paramters. This can be for all of the parameters or just a subset. We can use lr_find to suggest a learning rate for the language model and then que a trial with this learning rate. . lm_learn = create_lm() lm_learn.unfreeze() . lr_min,lr_steep = lm_learn.lr_find(suggestions=True) . lr_min, lr_steep . (0.014454397559165954, 0.033113110810518265) . study.enqueue_trial({&#39;learning_rate_unfrozen&#39;: lr_steep}) study.optimize(objective, n_trials=1) . /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:61: ExperimentalWarning: enqueue_trial is experimental (supported from v1.2.0). The interface can change in the future. . (#4) [0,5.322241306304932,4.736147403717041,&#39;00:24&#39;] (#4) [1,5.095097541809082,4.474568843841553,&#39;00:24&#39;] (#4) [2,4.91882848739624,4.365659713745117,&#39;00:24&#39;] (#4) [3,4.820737838745117,4.348053455352783,&#39;00:24&#39;] (#4) [0,3.5270116329193115,3.0885186195373535,&#39;00:27&#39;] (#4) [1,3.1028788089752197,2.8053553104400635,&#39;00:27&#39;] (#4) [2,2.7882776260375977,2.611638069152832,&#39;00:27&#39;] (#4) [3,2.49800705909729,2.539992094039917,&#39;00:27&#39;] . epoch train_loss valid_loss accuracy f1_score time . 0 | 2.325723 | 2.102552 | 0.010000 | 0.006709 | 00:10 | . 1 | 2.293266 | 2.006258 | 0.216667 | 0.332841 | 00:10 | . 2 | 2.258634 | 1.928858 | 0.566667 | 0.686662 | 00:10 | . [I 2020-06-05 15:28:58,707] Finished trial#3 with value: 0.6866621960133127 with parameters: {&#39;head_epochs&#39;: 4, &#39;learning_rate_frozen&#39;: 0.0003841551576945897, &#39;learning_rate_unfrozen&#39;: 0.033113110810518265, &#39;lm_body_epochs&#39;: 4}. Best is trial#3 with value: 0.6866621960133127. . Using the learning rate from the LR_finder gives us our best trial so far. This is likely to be because learning rate is a particularly important hyper-parameter. The suggested learning rate from lr_find may not always be the best but using either the suggested one or picking one based on the plot as a starting point for the trial may help Optuna to start from sensible starting point while still giving the freedom for optuna to diverge away from this in later trials if helps the objective function. . Pruning trials . The next feature of Optuna which helps make parameter searching more efficient is pruning. Pruning is a process for stopping bad trials early. . For example if we have the following three trials: . Trial 1 - epoch 1: 87% accuracy | Trial 2 - epoch 1: 85% accuracy | Trial 3 - epoch 1: 60% accuracy | . probably it&#39;s not worth continuing with trial 3. Pruning trials helps focus computational resources on trials which are likely to improve on previous trials. The likely here is important. It is possible that some trials may be pruned early which actually would have done better in the end. Optuna offers a number of different pruning algorithms, I won&#39;t cover these here but the documentation gives a good overview and includes links to the papers which propose the implemented pruning algorithms. . How to do pruning in Optuna? . Optuna has intergrations with various machine learning libraries. These intergrations can help with the pruning but setting up pruning manually is also pretty straight forward to do. . The two things we need to do is report the value and the stage in the training porcess: . trial.report(metric, step) . then we call: . if trial.should_prune(): raise optuna.exceptions.TrialPruned() . Depending on your objective function this will be put in different places. In the example of fine-tuning the language model, because we&#39;re trying to optimize the classification part it, it means the pruning step can only be called quite late in the traing loop. Ideally it would be called earlier but we still save a little bit of time on unpromising trials. . The new objective function with pruning: . def objective(trial): lm_learn = create_lm() lr_frozen = trial.suggest_loguniform(&quot;learning_rate_frozen&quot;, 1e-4, 1e-1) head_epochs = trial.suggest_int(&quot;head_epochs&quot;, 1, 5) with lm_learn.no_bar(): lm_learn.fit_one_cycle(head_epochs, lr_max=lr_frozen) # Unfrozen Language model lr_unfreeze = trial.suggest_loguniform(&quot;learning_rate_unfrozen&quot;, 1e-7, 1e-1) body_epochs = trial.suggest_int(&quot;lm_body_epochs&quot;, 1, 5) lm_learn.unfreeze() with lm_learn.no_bar(): lm_learn.fit_one_cycle(body_epochs, lr_unfreeze) lm_learn.save_encoder(&quot;finetuned&quot;) # Classification cl_learn = create_class_learn() cl_learn.load_encoder(&quot;finetuned&quot;) for step in range(3): cl_learn.fit(1) # Pruning intermediate_f1 = cl_learn.recorder.values[-1][ -1 ] # get f1 score for current step trial.report(intermediate_f1, step) # report f1 if trial.should_prune(): # let optuna decide whether to prune raise optuna.exceptions.TrialPruned() f1 = cl_learn.recorder.values[-1][-1] return f1 . We can load the same study as before using the python load_if_exists flag. . study_name = &quot;tunelm1830&quot; study = optuna.create_study( study_name=study_name, direction=&quot;maximize&quot;, storage=f&quot;sqlite:///{out_path}/optuma/example.db&quot;, load_if_exists=True, pruner=optuna.pruners.SuccessiveHalvingPruner(), ) . [I 2020-06-06 14:30:47,724] Using an existing study with name &#39;tunelm1830&#39; instead of creating a new one. . We can now run some more trials. Instead of specifying the number of trials we can also specify how long optuma should search for. . study.enqueue_trial({&#39;learning_rate_unfrozen&#39;: lr_steep}) study.optimize(objective, timeout=60*60*0.5) . and get the best trial: . study.best_trial . FrozenTrial(number=13, value=0.8657462002717475, datetime_start=datetime.datetime(2020, 6, 5, 15, 59, 26, 230967), datetime_complete=datetime.datetime(2020, 6, 5, 16, 3, 26, 392390), params={&#39;head_epochs&#39;: 4, &#39;learning_rate_frozen&#39;: 0.0012866609022148768, &#39;learning_rate_unfrozen&#39;: 1.3302852136460371e-06, &#39;lm_body_epochs&#39;: 4}, distributions={&#39;head_epochs&#39;: IntUniformDistribution(high=5, low=1, step=1), &#39;learning_rate_frozen&#39;: LogUniformDistribution(high=0.1, low=0.0001), &#39;learning_rate_unfrozen&#39;: LogUniformDistribution(high=0.1, low=1e-07), &#39;lm_body_epochs&#39;: IntUniformDistribution(high=5, low=1, step=1)}, user_attrs={}, system_attrs={&#39;completed_rung_0&#39;: 0.8156506309537317}, intermediate_values={0: 0.251088767516275, 1: 0.8156506309537317, 2: 0.8657462002717475}, trial_id=14, state=TrialState.COMPLETE) . and best value and pararms: . study.best_value, study.best_params . (0.8657462002717475, {&#39;head_epochs&#39;: 4, &#39;learning_rate_frozen&#39;: 0.0012866609022148768, &#39;learning_rate_unfrozen&#39;: 1.3302852136460371e-06, &#39;lm_body_epochs&#39;: 4}) . Paramters for the 1730s trials data . We can do the same process with the 1730s trials, starting with a suggested learning rate. . data_lm = load_lm_data(df_1730) data_class = load_class_data(df_1730, data_lm) lm_learn = create_lm() lm_learn.unfreeze() lr_min,lr_steep = lm_learn.lr_find(suggestions=True) . . def objective(trial): lm_learn = create_lm() lr_frozen = trial.suggest_loguniform(&quot;learning_rate_frozen&quot;, 1e-4, 1e-1) head_epochs = trial.suggest_int(&quot;head_epochs&quot;, 1, 5) with lm_learn.no_bar(): lm_learn.fit_one_cycle(head_epochs, lr_max=lr_frozen) # Unfrozen Language model lr_unfreeze = trial.suggest_loguniform(&quot;learning_rate_unfrozen&quot;, 1e-7, 1e-1) body_epochs = trial.suggest_int(&quot;lm_body_epochs&quot;, 1, 5) lm_learn.unfreeze() with lm_learn.no_bar(): lm_learn.fit_one_cycle(body_epochs, lr_unfreeze) lm_learn.save_encoder(&quot;finetuned&quot;) # Classification cl_learn = create_class_learn() cl_learn.load_encoder(&quot;finetuned&quot;) for step in range(3): cl_learn.fit(1) intermediate_f1 = cl_learn.recorder.values[-1][-1] trial.report(intermediate_f1, step) if trial.should_prune(): raise optuna.exceptions.TrialPruned() f1 = cl_learn.recorder.values[-1][-1] return f1 . . study_name = &quot;tunelm1730&quot; study = optuna.create_study( study_name=study_name, direction=&quot;maximize&quot;, storage=f&quot;sqlite:///{out_path}/optuma/example.db&quot;, load_if_exists=True, pruner=optuna.pruners.SuccessiveHalvingPruner(), ) . . [I 2020-06-08 15:06:54,474] Using an existing study with name &#39;tunelm1730&#39; instead of creating a new one. . study.enqueue_trial({&#39;learning_rate_unfrozen&#39;: lr_steep}) study.optimize(objective, timeout=60*60*0.5) . Trials can be accssed as part of the study object. Running trials for 30 mins with early pruning results in 20 trials . len(study.trials) . 20 . We can also see which was the best trial. . study.best_trial.number . 2 . The number of trials run depends mainly on how long your model takes to train, the size of the paramter search space and your patience. If trials are failing to improve better scores for a long time it&#39;s probably better to actively think about how to improve your approach to the problem (better data, more data, chaning model design etc.) rather than hoping hyperaparmet tuning will fix the problem. . Comparing language model parameters . Previous trials can be loaded using load_study . study1830 = optuna.load_study(&#39;tunelm1830&#39;, storage=f&#39;sqlite:///{out_path}/optuma/example.db&#39;) study1730 = optuna.load_study(&#39;tunelm1730&#39;, storage=f&#39;sqlite:///{out_path}/optuma/example.db&#39;) . First comparing the best f1 values for both datasets: . print(f&#39;Best 1830 value was: {study1830.best_value:.3}&#39;) print(f&#39;Best 1730 value was: {study1730.best_value:.3}&#39;) . Best 1830 value was: 0.866 Best 1730 value was: 0.781 . The paramters used to get the best value: . 1830 parameters . {&#39;head_epochs&#39;: 4, &#39;learning_rate_frozen&#39;: 0.0012866609022148768, &#39;learning_rate_unfrozen&#39;: 1.3302852136460371e-06, &#39;lm_body_epochs&#39;: 4} . 1730 parameters . {&#39;head_epochs&#39;: 3, &#39;learning_rate_frozen&#39;: 0.002145480897071231, &#39;learning_rate_unfrozen&#39;: 9.889236991663078e-06, &#39;lm_body_epochs&#39;: 1} . Specific parameters can also be accessed . study1830.best_params[&#39;learning_rate_unfrozen&#39;], study1730.best_params[&#39;learning_rate_unfrozen&#39;] . (1.3302852136460371e-06, 9.889236991663078e-06) . Visualizations . Optuna has a variety of visulizations, I will only briefly show a few of these here. . plot_intermediate_values shows the intermediate values. This can be useful for getting a sense of how trials progress and also help give a sense of whether some trials are being pruned prematurely . optuna.visualization.plot_intermediate_values(study1830) . . . plot_parallel_coordinate plots parameters choices in relation to values. It can be hard to read these plots but they can also be helpful for giving a sense of which choices for parameters work best. . optuna.visualization.plot_parallel_coordinate(study1830) . . . Parameter importance . Optuna has experimental support for getting parameter importance. . optuna.importance.get_param_importances(study1730) . /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:61: ExperimentalWarning: get_param_importances is experimental (supported from v1.3.0). The interface can change in the future. /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:83: ExperimentalWarning: MeanDecreaseImpurityImportanceEvaluator is experimental (supported from v1.5.0). The interface can change in the future. . OrderedDict([(&#39;learning_rate_frozen&#39;, 0.43423246892923717), (&#39;learning_rate_unfrozen&#39;, 0.2904735896601219), (&#39;head_epochs&#39;, 0.2433021650269149), (&#39;lm_body_epochs&#39;, 0.031991776383726155)]) . optuna.importance.get_param_importances(study1830) . /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:61: ExperimentalWarning: get_param_importances is experimental (supported from v1.3.0). The interface can change in the future. /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:83: ExperimentalWarning: MeanDecreaseImpurityImportanceEvaluator is experimental (supported from v1.5.0). The interface can change in the future. . OrderedDict([(&#39;learning_rate_unfrozen&#39;, 0.35548906967729954), (&#39;learning_rate_frozen&#39;, 0.33998779901100146), (&#39;head_epochs&#39;, 0.21196438930810765), (&#39;lm_body_epochs&#39;, 0.09255874200359132)]) . These are broadly similar although learning rate frozen/unfrozen are in different places for the 1730 and 1830 trials. . Multi objective . Optuna has experimental support for multi-objective optimization. This might be useful if you don&#39;t want to optimize for only one metrics. . An alternative to using this approach is to report other things you care about during the trial but don&#39;t directly want to optimize for. As an example, you might mostly care about the accuracy of a model but also care a bit about how long it takes to do inference. . One approach is to use a multi-objective trial. An alternative is to instead log inference time as part of the trial and continue to optimize for other metrics. You can then later on balance the accuracy of different trials with the inference time. It may turn out later that a slightly slower inference time can be dealt with by scaling vertically. Not prematurely optimizing for multi-objectives can therefore give you more flexibility. To show this in practice I&#39;ll use an image classification dataset. . The data . The data is images of maps and other things from historic newspapers. The aim is to classify whether the image is a map or something else. . dls = ImageDataLoaders.from_folder( &quot;data/1905_maps/&quot;, valid_pct=0.3, item_tfms=Resize(256) ) dls.show_batch() . learn.unfreeze() lr_min,unfrozen_lr_steep = learn.lr_find(suggestions=True) . Excessive model parameter search . Since the time to train the model is more reasonable we can add a more parameters to the search space. In practice this is pretty overkill but is useful as an example of working with the outputs of trials with many parameters. . def objective(trial): apply_tfms = trial.suggest_categorical(&quot;apply_tfms&quot;, [True, False]) if apply_tfms: aug_tfms = aug_transforms( mult=trial.suggest_uniform(&quot;mult&quot;, 0.0, 1.0), do_flip=trial.suggest_categorical(&quot;do_flip&quot;, [True, False]), flip_vert=trial.suggest_categorical(&quot;flip_vert&quot;, [True, False]), max_rotate=trial.suggest_uniform(&quot;max_rotate&quot;, 0, 180), max_zoom=trial.suggest_uniform(&quot;max_zoom&quot;, 0, 3.0), max_lighting=trial.suggest_uniform(&quot;max_lighting&quot;, 0.0, 1.0), ) else: aug_tfms = None dls = ImageDataLoaders.from_folder( &quot;data/1905_maps/&quot;, valid_pct=0.3, item_tfms=Resize(256), aug_transforms=aug_tfms ) model = trial.suggest_categorical( &quot;model&quot;, [&quot;resnet18&quot;, &quot;resnet50&quot;, &quot;xresnet50&quot;, &quot;squeezenet1_0&quot;, &quot;densenet121&quot;] ) learn = cnn_learner( dls, arch=eval(model), pretrained=True, metrics=[F1Score(average=&quot;weighted&quot;)] ).to_fp16() epochs = trial.suggest_int(&quot;epochs&quot;, 1, 10) for step in range(epochs): with learn.no_bar(): learn.fit_one_cycle( 1, base_lr=trial.suggest_loguniform(&quot;learning_rate&quot;, 1e-5, 1e-1) ) unfrozen_epochs = trial.suggest_int(&quot;unfrozen_epochs&quot;, 1, 10) unfrozen_lr = trial.suggest_loguniform(&quot;unfrozen_learning_rate&quot;, 1e-10, 1e-1) learn.unfreeze() for step in range(unfrozen_epochs): with learn.no_bar(): learn.fit_one_cycle(1, lr_max=unfrozen_lr) int_f1 = learn.recorder.values[-1][-1] trial.report(int_f1, step) if trial.should_prune(): raise optuna.exceptions.TrialPruned() t0 = time.time() learn.validate() t1 = time.time() execute_time = t1 - t0 trial.set_user_attr(&quot;execute_time&quot;, execute_time) f1 = learn.recorder.values[-1][-1] return f1 . Create the study . study_name = &quot;mapsmegastudyXL&quot; # Unique identifier of the study. study = optuna.create_study( direction=&quot;maximize&quot;, load_if_exists=True, study_name=study_name, storage=f&quot;sqlite:///{out_path}/optuma/blog.db&quot;, pruner=optuna.pruners.SuccessiveHalvingPruner(min_resource=2), ) . [I 2020-06-07 15:03:24,138] Using an existing study with name &#39;mapsmegastudyXL&#39; instead of creating a new one. . Queue up with some parameters . study.enqueue_trial( { &quot;pre_trained&quot;: True, &quot;apply_tfms&quot;: True, &quot;epochs&quot;: 5, &quot;learning_rate&quot;: lr_steep, &quot;model&quot;: &quot;resnet50&quot;, &quot;unfrozen_learning_rate&quot;: unfrozen_lr_steep, } ) study.optimize(objective, n_trials=1, show_progress_bar=True) . /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:61: ExperimentalWarning: enqueue_trial is experimental (supported from v1.2.0). The interface can change in the future. /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:61: ExperimentalWarning: Progress bar is experimental (supported from v1.2.0). The interface can change in the future. . (#5) [0,1.162647008895874,1.0643662214279175,0.38594077225581136,&#39;00:04&#39;] (#5) [0,1.1730060577392578,0.8583190441131592,0.45458674870439575,&#39;00:02&#39;] (#5) [0,0.7940309047698975,0.40110471844673157,0.8101934029975151,&#39;00:02&#39;] (#5) [0,0.3774714767932892,0.3251221776008606,0.8738329238329239,&#39;00:02&#39;] (#5) [0,0.20592834055423737,0.304998517036438,0.8914149443561209,&#39;00:02&#39;] (#5) [0,0.14400754868984222,0.3399428725242615,0.9003332765709003,&#39;00:03&#39;] (#5) [0,0.11649172753095627,0.3571062982082367,0.8729641116526362,&#39;00:03&#39;] . [I 2020-06-07 15:03:57,405] Finished trial#0 with value: 0.8729641116526362 with parameters: {&#39;apply_tfms&#39;: True, &#39;do_flip&#39;: False, &#39;epochs&#39;: 5, &#39;flip_vert&#39;: True, &#39;learning_rate&#39;: 0.00015848931798245758, &#39;max_lighting&#39;: 0.5155363265412508, &#39;max_rotate&#39;: 93.50185801538605, &#39;max_zoom&#39;: 2.5014402368129147, &#39;model&#39;: &#39;resnet50&#39;, &#39;mult&#39;: 0.7973732804273224, &#39;unfrozen_epochs&#39;: 2, &#39;unfrozen_learning_rate&#39;: 1.4454397387453355e-05}. Best is trial#0 with value: 0.8729641116526362. . queue up with some less sensible defaults . study.enqueue_trial( {&quot;pre_trained&quot;: False, &quot;apply_tfms&quot;: False, &quot;epochs&quot;: 1, &quot;unfrozen_epochs&quot;: 1} ) study.optimize(objective, n_trials=1, show_progress_bar=True) . /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:61: ExperimentalWarning: enqueue_trial is experimental (supported from v1.2.0). The interface can change in the future. /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:61: ExperimentalWarning: Progress bar is experimental (supported from v1.2.0). The interface can change in the future. . (#5) [0,1.1455873250961304,1.7333940267562866,0.3123010228273386,&#39;00:01&#39;] (#5) [0,1.0485259294509888,1.4432364702224731,0.4545249081834448,&#39;00:01&#39;] . [I 2020-06-07 15:04:18,823] Finished trial#1 with value: 0.4545249081834448 with parameters: {&#39;apply_tfms&#39;: False, &#39;epochs&#39;: 1, &#39;learning_rate&#39;: 1.4039901997074766e-05, &#39;model&#39;: &#39;resnet18&#39;, &#39;unfrozen_epochs&#39;: 1, &#39;unfrozen_learning_rate&#39;: 4.041607859100835e-07}. Best is trial#0 with value: 0.8729641116526362. . Now optimize for 500 trials . study.optimize(objective, n_trials=500,show_progress_bar=True) . study = optuna.load_study(&#39;mapsmegastudyXL&#39;, storage=f&#39;sqlite:///{out_path}/optuma/blog.db&#39;) . The best finishing values and parameters: . study.best_value, study.best_params . (0.963975663975664, {&#39;apply_tfms&#39;: True, &#39;do_flip&#39;: True, &#39;epochs&#39;: 10, &#39;flip_vert&#39;: False, &#39;learning_rate&#39;: 0.0785689562916925, &#39;max_lighting&#39;: 0.5064203068969654, &#39;max_rotate&#39;: 168.972217754609, &#39;max_zoom&#39;: 1.6141746329756919, &#39;model&#39;: &#39;densenet121&#39;, &#39;mult&#39;: 0.6087267126078458, &#39;unfrozen_epochs&#39;: 4, &#39;unfrozen_learning_rate&#39;: 7.6080876225791396e-06}) . Visualization . Taking a look at parallel_coordinate in this case gives some sense of which options work best. . optuna.visualization.plot_parallel_coordinate(study) . . . Importance . optuna.importance.get_param_importances(study) . /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:61: ExperimentalWarning: get_param_importances is experimental (supported from v1.3.0). The interface can change in the future. /usr/local/lib/python3.6/dist-packages/optuna/_experimental.py:83: ExperimentalWarning: MeanDecreaseImpurityImportanceEvaluator is experimental (supported from v1.5.0). The interface can change in the future. . OrderedDict([(&#39;unfrozen_learning_rate&#39;, 0.6945560978629778), (&#39;epochs&#39;, 0.13207296757949719), (&#39;model&#39;, 0.07996254760084977), (&#39;unfrozen_epochs&#39;, 0.04455237119259635), (&#39;learning_rate&#39;, 0.04014544684326522), (&#39;apply_tfms&#39;, 0.008710568920813712)]) . Learning rate is by far the most important learning rate, again this suggests that using learning rate finder makes a lot of sense as a starting point. . Working with Optuna trial data . There are now ~500 trials which are stored in the study. Each of these trials contains the parameters used, metadata about the trial, the value of the thing being optimized, and importantly for this example the user attribute which stores the validation time. Optuna makes it very easy to export this information to a dataframe. . df = study.trials_dataframe() df.head(3) . number value datetime_start datetime_complete duration params_apply_tfms params_do_flip params_epochs params_flip_vert params_learning_rate params_max_lighting params_max_rotate params_max_zoom params_model params_mult params_unfrozen_epochs params_unfrozen_learning_rate user_attrs_execute_time system_attrs_completed_rung_0 system_attrs_completed_rung_1 system_attrs_fixed_params state . 0 0 | 0.872964 | 2020-06-07 15:03:29.911841 | 2020-06-07 15:03:57.151460 | 00:00:27.239619 | True | False | 5.0 | True | 0.000158 | 0.515536 | 93.501858 | 2.50144 | resnet50 | 0.797373 | 2.0 | 1.445440e-05 | 0.82319 | NaN | NaN | {&#39;pre_trained&#39;: True, &#39;apply_tfms&#39;: True, &#39;epochs&#39;: 5, &#39;learning_rate&#39;: 0.00015848931798245758, &#39;model&#39;: &#39;resnet50&#39;, &#39;unfrozen_learning_rate&#39;: 1.4454397387453355e-05} | COMPLETE | . 1 1 | 0.454525 | 2020-06-07 15:04:11.520248 | 2020-06-07 15:04:18.419082 | 00:00:06.898834 | False | NaN | 1.0 | NaN | 0.000014 | NaN | NaN | NaN | resnet18 | NaN | 1.0 | 4.041608e-07 | 0.67698 | NaN | NaN | {&#39;pre_trained&#39;: False, &#39;apply_tfms&#39;: False, &#39;epochs&#39;: 1, &#39;unfrozen_epochs&#39;: 1} | COMPLETE | . 2 2 | NaN | 2020-06-07 15:04:32.047588 | NaT | NaT | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | RUNNING | . We can now easily work with the trial data using pandas. Lets start by getting the best two values . df.sort_values([&#39;value&#39;], ascending=False).head(2) . Unnamed: 0 number value datetime_start datetime_complete duration params_apply_tfms params_do_flip params_epochs params_flip_vert ... params_max_zoom params_model params_mult params_unfrozen_epochs params_unfrozen_learning_rate user_attrs_execute_time system_attrs_completed_rung_0 system_attrs_completed_rung_1 system_attrs_fixed_params state . 177 177 | 177 | 0.963976 | 2020-06-07 16:48:36.232551 | 2020-06-07 16:49:21.393454 | 0 days 00:00:45.160903000 | True | True | 10.0 | False | ... | 1.614175 | densenet121 | 0.608727 | 4.0 | 7.608088e-06 | 0.880459 | 0.954955 | NaN | NaN | COMPLETE | . 302 302 | 302 | 0.955064 | 2020-06-07 18:11:00.667449 | 2020-06-07 18:11:45.658241 | 0 days 00:00:44.990792000 | True | True | 10.0 | False | ... | 0.921689 | densenet121 | 0.115708 | 4.0 | 6.210737e-10 | 0.878865 | 0.945946 | NaN | NaN | COMPLETE | . 2 rows × 23 columns . We can see how often transforms were applied in the trials . df[&#39;params_apply_tfms&#39;].value_counts() . True 360 False 142 Name: params_apply_tfms, dtype: int64 . Viewing the number of trials for each model which had a value over 90 . df[&#39;params_model&#39;][df[&#39;value&#39;] &gt;= 0.90].value_counts() . densenet121 181 resnet50 9 squeezenet1_0 2 Name: params_model, dtype: int64 . Filtering a bit more aggressively (value above 94) . df94 = df[df[&#39;value&#39;] &gt;= 0.94] . len(df94) . 13 . How often were transforms applied for these trials . df94[&#39;params_apply_tfms&#39;].value_counts() . True 11 False 2 Name: params_apply_tfms, dtype: int64 . The number of unfrozen epochs . df94[&#39;params_unfrozen_epochs&#39;].value_counts() . 4.0 6 2.0 3 3.0 2 6.0 1 5.0 1 Name: params_unfrozen_epochs, dtype: int64 . Getting back to the validation time we can get the max, min and mean values . df[&#39;user_attrs_execute_time&#39;].max(), df[&#39;user_attrs_execute_time&#39;].min(), df[&#39;user_attrs_execute_time&#39;].mean() . (0.9760787487030028, 0.6313643455505371, 0.8461264789613903) . If we did care about reducing the execution time we could use these values to find the trial with the shortest execution time: . df94[&#39;user_attrs_execute_time&#39;].sort_values() . 96 0.837618 426 0.848863 394 0.849243 395 0.851704 438 0.852672 500 0.863168 344 0.875520 432 0.877422 302 0.878865 177 0.880459 473 0.884703 372 0.906770 294 0.907221 Name: user_attrs_execute_time, dtype: float64 . If we were happy with slightly lower performance we could pick the study with the shortest execution time which is still achieves a f1 above 94% . df94.loc[96] . number 96 value 0.945755 datetime_start 2020-06-07 15:57:20.382634 datetime_complete 2020-06-07 15:57:54.848296 duration 0 days 00:00:34.465662 params_apply_tfms False params_do_flip NaN params_epochs 9 params_flip_vert NaN params_learning_rate 8.47479e-05 params_max_lighting NaN params_max_rotate NaN params_max_zoom NaN params_model densenet121 params_mult NaN params_unfrozen_epochs 2 params_unfrozen_learning_rate 4.31178e-07 user_attrs_execute_time 0.837618 system_attrs_completed_rung_0 NaN system_attrs_completed_rung_1 NaN system_attrs_fixed_params NaN state COMPLETE Name: 96, dtype: object . This is a slightly artificial example but hopefully shows the possibility of logging user attributes which can then be accessed easily later without prematurely optimizing for something which may not be important. . Further reading . Hopefully this post has been a helpful overview of Optuna with a somewhat realistic use case. I would recommend reading the Optuna docs which covers things in much more detail. . References . 1. Auto ml [auto-ml, fastai blog(https://www.fast.ai/2018/07/16/auto-ml2/#auto-ml↩ . 2. introducting ulmfit nlp.fast.ai/classification/2018/05/15/introducting-ulmfit.html↩ . 3. Takuya Akiba, Shotaro Sano, Toshihiko Yanase, Takeru Ohta,and Masanori Koyama. 2019. Optuna: A Next-generation Hyperparameter Optimization Framework. In KDD.↩ .",
            "url": "https://danielvanstrien.xyz/hyperparameter%20optimisation/optimisation/optuna/fastai2/transfer%20learning/2020/07/01/optuna.html",
            "relUrl": "/hyperparameter%20optimisation/optimisation/optuna/fastai2/transfer%20learning/2020/07/01/optuna.html",
            "date": " • Jul 1, 2020"
        }
        
    
  
    
        ,"post11": {
            "title": "Multi-model metadata generation",
            "content": "Learning from multiple input types . Deep learning models usually take one type of input (image, text etc.) to predict output labels (category, entities etc). This usually makes sense if the data you are using to make predictions contains a lot of information. i.e. a chunk of text from a movie review or an image. . Recently I have been playing around with a Website Classification Dataset from the UK web archive. The dataset is derived from a manually curated web archive which contains a primary and secondary category for each web page. The UK web archive has made a dataset available based on this archive which contains the manually classified subject categories alongside the page URL and the page title. . As part of playing around with this dataset I was keen to see if a multi-input model would work well. In this case exploring a model that takes both text and tabular data as input. A preview of the data: . Primary Category Secondary Category Title URL . 0 Arts &amp; Humanities | Architecture | 68 Dean Street | http://www.sixty8.com/ | . 1 Arts &amp; Humanities | Architecture | Abandoned Communities | http://www.abandonedcommunities.co.uk/ | . 2 Arts &amp; Humanities | Architecture | Alexander Thomson Society | http://www.greekthomson.com/ | . 3 Arts &amp; Humanities | Architecture | Arab British Centre, The | http://www.arabbritishcentre.org.uk/ | . 4 Arts &amp; Humanities | Architecture | Architectural Association School of Architecture | http://www.aaschool.ac.uk/ | . Based on this data the UK web archive are interested: . &quot;in understanding whether high-level metadata like this can be used to train an appropriate automatic classification system so that we might use this manually generated dataset to partially automate the categorisation of our larger archives.&quot; . This is going to be fairly tricky but offers a nice excuse to try to use models with multiple inputs to predict our categories. . Looking at the data . Taking a closer look at the data: . Unique primary categories . len(df[&#39;Primary Category&#39;].unique()) . 24 . Unique secondary categories . len(df[&#39;Secondary Category&#39;].unique()) . 104 . Predicting a 104 different labels is going to be pretty difficult so I&#39;ve only used &#39;Primary Category&#39; as the the y target. What is the distribution of these categories like? . Arts &amp; Humanities 5299 Government, Law &amp; Politics 4832 Business, Economy &amp; Industry 2988 Society &amp; Culture 2984 Science &amp; Technology 2420 Medicine &amp; Health 2164 Education &amp; Research 2118 Company Web Sites 843 Digital Society 737 Sports and Recreation 710 Religion 417 Travel &amp; Tourism 374 Social Problems and Welfare 270 Politics, Political Theory and Political Systems 123 Crime, Criminology, Police and Prisons 101 Literature 87 Law and Legal System 81 Computer Science, Information Technology and Web Technology 54 Libraries, Archives and Museums 52 Environment 38 History 34 Publishing, Printing and Bookselling 26 Popular Science 23 Life Sciences 23 Name: Primary Category, dtype: int64 . 😬 We also have a fairly skewed datasets. I could drop some of rows which don&#39;t occur often but since the main objective here is to see if we can use a multi-input model we&#39;ll leave the data as it is for now. . Multi-input model . The rest of the notebook will describe some experiments with using fastai to create a model which takes tabular and text data as an input. The aim here wasn&#39;t for me to create the best model but get my head around how to combine models. I heavily relied on some existing notebooks, kaggle writeup and forum posts on the fastai forums. . Tabular model . In the dataset above we start of with two columns of data which can be used as inputs for the model. The title is fairly obviously something which we can treat like other text inputs. The URL is a little less obvious. It could be treated as a text input but an alternative is to treat a URL as parts which each contain some information which could be useful for our model. . http://www.specialschool.org/ http://www.bbc.co.uk/news/health-12668398 http://www.monarchit.co.uk/ . Each part of the URL could be split into smaller parts . [&#39;http://www&#39;, &#39;darwincountry&#39;, &#39;org/&#39;] . Whether a url has &#39;.org&#39; or &#39;.uk&#39; or &#39;.com&#39; could be meaningful for predicting our categories (it might also not be meaningful). It also offers us a way of taking the URLs and composing it into a format which looks more tabular. . scheme url1 url3 url4 url5 . 20011 http | www | org | NaN | NaN | . 15825 http | www | com | NaN | NaN | . 6068 http | www | co | uk | NaN | . 16507 http | www | co | uk | NaN | . 9723 http | www | co | uk | NaN | . So far I&#39;ve only done this very crudely. I suspect tidying up this part of the data will help improve things. At this point though we have something which is a little more tabular looking we can pass to fastai.tabular learner. Now we have some &#39;categories&#39; rather than unique urls. . print(len(df.url3.unique())) print(len(df.url4.unique())) . 279 56 . How does this tabular model do? . Once some preprocessing of the url has been done we train a model using the tabular learner. I didn&#39;t do much to try to optimize this model. Tracking best f2 score we end up with: . Better model found at epoch 36 with f_beta value: 0.17531482875347137 and an accuracy of 0.334121 . How well does a text model do? . Next I tried training using the title field in a NLP model. I tried a few things here. . SentencePiece tokenization . By default fastai uses SpaCy to do tokenization with a few additional special tokens added by fastai. I wanted to see if using sentencePiece would work better for processing title fields. SentencePiece allows for various sub-word tokeinzation. This can be useful for agglutinative languages but could also be useful when you have a lot of out of vocabulary words in your corpus. I wanted to see if this also was useful for processing titles since these may contain domain specific terms. I only tried using SentencePiece with &#39;unigram&#39; tokenization. The best score I got for this was: . Better model found at epoch 1 with f_beta value: 0.21195338666439056. . Default SpaCy tokenization . I compared the above to using the default fastai tokenizer which uses SpaCy. In this case the default approach worked better. This is probably because we didn&#39;t have a large pre-trained model using the SentencePiece tokenization to use as a starting point. The best score I got for this model was: . Better model found at epoch 27 with f_beta value: 0.33327043056488037. . Using the URL as text input . I wanted to do a quick comparison to the tabular model and use the URL as a text input instead. In this case I used SentencePiece with byte-pair-encoding (BPE). The best score in this case was: . Better model found at epoch 3 with f_beta value: 0.2568161189556122. . This might end up being a better approach compared to the tabular approach described above. . Combining inputs . Neither of these models is doing super well but my main question was whether combining the two would improve things at all. There are different approaches to combining these models. I followed existing examples and removed some layers from the text and tabular models which are then combined in a concat model. I won&#39;t cover all the steps here but all the notebooks can be found in this GitHub repo. . One of the things we need to do to create a model with multiple input is create a new Pytorch dataset which combines our text and tabular x inputs with our target. This is pretty straightforward: . class ConcatDataset(Dataset): def __init__(self, x1, x2, y): self.x1,self.x2,self.y = x1,x2,y def __len__(self): return len(self.y) def __getitem__(self, i): return (self.x1[i], self.x2[i]), self.y[i] . . One of the other pieces was creating a ConcatModel . class ConcatModel(nn.Module): def __init__(self, model_tab, model_nlp, layers, drops): super().__init__() self.model_tab = model_tab self.model_nlp = model_nlp lst_layers = [] activs = [nn.ReLU(inplace=True),] * (len(layers)-2) + [None] for n_in,n_out,p,actn in zip(layers[:-1], layers[1:], drops, activs): lst_layers += bn_drop_lin(n_in, n_out, p=p, actn=actn) # https://docs.fast.ai/layers.html#bn_drop_lin self.layers = nn.Sequential(*lst_layers) def forward(self, *x): x_tab = self.model_tab(*x[0]) x_nlp = self.model_nlp(x[1])[0] x = torch.cat([x_tab, x_nlp], dim=1) return self.layers(x) . . lst_layer is dependent on the layers from the tabular and nlp models. This layer is manually defined at the moment, so if changes are made to the number of layers in the tab model this needs to be manually changed. . bn_drop_lin is a fastai helper function that returns a a sequence of batch normalization, dropout and a linear layer which is the final layer of the model. . How does this combined model do? &#129335;&#8205;&#9794;&#65039; . The best result I got wasf_beta value: 0.39341238141059875 with an accuracy of 0.595348. A summary of the scores for each models: . Model F2 score . SentencePiece text | 0.211 | . Spacy text | 0.333 | . Tabular | 0.175 | . Concat | 0.393 | . This provides some improvement on the tabular or nlp models on their own. I found the combined model was fairly tricky to train and suspect that there could be some improvements in how the model is set up that might improve it&#39;s performance. I am keen to try a similar approach with a dataset where there is more abundant information available to train with. . tl;dr . It wasn&#39;t possible to get a very good f2 score on this website classification dataset. As the UK web archive say: . We expect that a appropriate classifier might require more information about each site in order to produce reliable results, and are looking at augmenting this dataset with further information in the future. Options include:For each site, make the titles of every page on that site available. For each site, extract a set of keywords that summarise the site, via the full-text index. . I suspect that having a either of these additional components would help improve the performance of the classifier. .",
            "url": "https://danielvanstrien.xyz/metadata/multi-model/2020/05/03/multi-model.html",
            "relUrl": "/metadata/multi-model/2020/05/03/multi-model.html",
            "date": " • May 3, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hi, I’m Daniel. I’m a librarian interested in using computational methods to do research with library and archive collections. I’m particularly excited by the possibilities of using deep-learning both as part of the “day-to-day” processes within a library setting and for enabling new kinds of research. . I currently work at the British Library as a Digital Curator for the Living with Machines project. .",
          "url": "https://danielvanstrien.xyz/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "Selected projects",
          "content": "This page collects selected projects that I have worked on. . Machine learning projects . flyswot: using computer vision to detect ‘fake flysheets’ . Related Posts . An increasing challenge for libraries is managing the scale of digitised material resulting from digitisation projects and ‘born digital’ materials. This project aims to detect mislabelled digitised manuscript pages. . A manuscript page with the correct label &quot;fse.ivr&quot; As a result of the limitations of a previous system for hosting digitised manuscript images, many images have incorrect page metadata associated with the image. An image has been correctly labelled as an ‘end flysheet’ in the example above. This label is represented by the fse label, which is included in the filename for the image. However other types of manuscript pages also have this label incorrectly assigned, i.e. a ‘cover’ has fse in the filename. There is around a petabyte of images to review before ingesting a new library system. This project uses computer vision to support library staff in processing this collection. At the moment, this project does the following: . pulls in an updated dataset of training examples | trains a model on these images | the model architecture has multiple heads to allow the model to make both a ‘crude’ prediction for whether the image is incorrectly labelled and a ‘full’ prediction for the true label. | once a new version of the model has been trained, it is pushed to the 🤗 model hub. | the end-user uses the model through a command-line tool which is pointed at a directory of images to be checked. | . The code for the command-line tool is available here: github.com/davanstrien/flyswot/ . Some of the tools used: fastai, DVC, Weights and Biases, 🤗 model hub, pytest, nox, poetry . Book Genre Detection . . This project created machine learning models which would predict whether a book was ‘fiction’ or ‘non- fiction’ based on the book title: . The project was developed to address a gap in metadata in a large scale digitised book collection. | The project used weak supervision to generate a more extensive training set beyond the initial human-generated annotations. | Currently, two models are publicly available, one via the 🤗 Model Hub and one via Zenodo. | The process of creating the models is documented in a Jupyter Book. This documentation aims to communicate the critical steps in the machine learning pipeline to aid other people in the sector develop similar models. https://huggingface.co/spaces https://huggingface.co/spaces/BritishLibraryLabs/British-Library-books-genre-classifier-v2 | . Some of the tools used: fastai, transformers, blurr, Hugging face model hub, Jupyter Book, Snorkel, Gradio . Datasets . British Library books . Extracted plain text and other metadata files from ALTO XML https://github.com/davanstrien/digitised-books-ocr-and-metadata | Added the dataset to the 🤗 datasets hub | . British Library Books Genre data . Created a datasets loading script and prepared a Dataset card for a dataset supporting book genre detection using machine learning: https://huggingface.co/datasets/blbooksgenre | . Datasets to support programming historian lessons . I think having more realistic datasets is important for teaching machine learning effectively. As a result, I created two datasets for two under review Programming Historian lessons. . 19th Century United States Newspaper Advert images with ‘illustrated’ or ‘non illustrated’ labels . | 19th Century United States Newspaper images predicted as Photographs with labels for “human”, “animal”, “human-structure” and “landscape” . | . Workshop datasets . Images from Newspaper Navigator predicted as maps, with human corrected labels | . Workshop materials . Computer Vision for the Humanities workshop: This workshop aims to provide an introduction to computer vision aimed for humanities applications. In particular this workshop focuses on providing a high level overivew of machine learning based approaches to computer vision focusing on supervised learning. The workshop includes discussion on working with historical data. The materials are based on in progress Programming Historian lessons. | Working with maps at scale using Computer Vision and Jupyter notebooks | Introduction to Jupyter Notebooks: the weird and the wonderful | Image Search: Materials for a workshop on image search with a focus on heritage data. The workshop is based on a blog post Image search with 🤗 datasets but goes into a little bit more detail. | . Tutorials . Jupyter book showing how to build an ML powered book genre classifier | A (brief) history of advertising in US Newspapers using computer vision | (Under review) Computer Vision for the Humanities: An Introduction to Deep Learning for Image Classification, Programming Historian lessons | (Under development) Intro to AI for GLAM, Carpentries Lesson | . Code . You can view much of my code related activity on GitHub . Publications . Semantic Scholar page | OCRCID page | .",
          "url": "https://danielvanstrien.xyz/projects/",
          "relUrl": "/projects/",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page12": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://danielvanstrien.xyz/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}